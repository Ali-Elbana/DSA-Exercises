# Longest Common Subsequence (LCS) Algorithm - Dynamic Programming Implementation

## Problem Overview

The **Longest Common Subsequence (LCS)** problem finds the longest sequence of characters that appears in the same relative order in two given strings, but not necessarily consecutively. This is a fundamental problem in **dynamic programming** and has applications in bioinformatics, version control systems, and text comparison.

## Algorithm Description

This implementation uses a **2D dynamic programming table** to solve both:

1. **Length of LCS**: Finding the length of the longest common subsequence
2. **Actual LCS String**: Reconstructing the subsequence itself through backtracking

### Key Characteristics

- **Problem Type**: String matching and sequence alignment
- **Approach**: Dynamic programming with tabulation
- **Time Complexity**: O(m×n) where m and n are string lengths
- **Space Complexity**: O(m×n) for the DP table

## Code Analysis

### Function Structure

```cpp
// Input handling
void get_string(string & inStr);

// Returns length of LCS
int longestCommonSubsequenceNum(string text1, string text2);

// Returns actual LCS string
string longestCommonSubsequenceStr(string text1, string text2);
```

### Core Algorithm Logic

#### 1. DP Table Construction

Both functions use the same recurrence relation:

```cpp
if(text2[i] == text1[j]) {
    graph[i][j] = 1 + graph[i-1][j-1];  // Characters match
} else {
    graph[i][j] = std::max(graph[i][j-1], graph[i-1][j]);  // Take maximum
}
```

#### 2. String Preprocessing

```cpp
// Add space at beginning for 1-indexed processing
text1 = " " + text1;
text2 = " " + text2;

// Create DP table with extra row and column
vector<vector<int>> graph(tx2Len + 1, vector<int>(tx1Len + 1, 0));
```

#### 3. LCS Reconstruction (Backtracking)

```cpp
while(i > 0 && j > 0) {
    if(graph[i][j] > graph[i][j-1]) {      // Current > left
        if(graph[i][j] == graph[i-1][j]) { // Current == top
            i--;  // Move up (no character added)
        } else {
            result = text2[i] + result;    // Add character to result
            i--; j--;                      // Move diagonally
        }
    } else {
        j--;  // Move left
    }
}
```

## Dynamic Programming Table Visualization

For strings "ABCDGH" and "AEDFHR":

|     |     | A   | B   | C   | D   | G   | H   |
| --- | --- | --- | --- | --- | --- | --- | --- |
|     | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| A   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
| E   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
| D   | 0   | 1   | 1   | 1   | 2   | 2   | 2   |
| F   | 0   | 1   | 1   | 1   | 2   | 2   | 2   |
| H   | 0   | 1   | 1   | 1   | 2   | 2   | 3   |
| R   | 0   | 1   | 1   | 1   | 2   | 2   | 3   |

**Result**: LCS = "ADH" with length 3

## Algorithm Steps

### Phase 1: Length Calculation

1. **Initialize**: Create (m+1)×(n+1) table filled with zeros
2. **Fill Table**: Use recurrence relation to populate each cell
3. **Result**: Bottom-right cell contains LCS length

### Phase 2: String Reconstruction

1. **Start**: Begin at bottom-right corner of table
2. **Backtrack**: Follow optimal path using table values
3. **Build String**: Add characters when moving diagonally
4. **Terminate**: Stop when reaching top-left corner

## Key Insights

### Why Dynamic Programming Works

- **Optimal Substructure**: LCS of prefixes contributes to LCS of full strings
- **Overlapping Subproblems**: Same subproblems solved multiple times
- **Bottom-up Construction**: Build solution from smaller subproblems

### Recurrence Relation Explained

```c++
LCS[i][j] = {
    if i = 0 or j = 0
	    1 + LCS[i-1][j-1],          
    if text1[i] = text2[j]
	    max(LCS[i-1][j], LCS[i][j-1]), 
}
```

## Applications

### Real-World Uses

- **Version Control**: Git diff algorithms
- **Bioinformatics**: DNA/protein sequence alignment
- **Plagiarism Detection**: Text similarity analysis
- **File Comparison**: Tools like `diff` command
- **Spell Checkers**: Finding closest matching words

### Algorithm Variants

- **Space-Optimized LCS**: O(min(m,n)) space complexity
- **Longest Common Substring**: Requires consecutive characters
- **Edit Distance**: Related problem using similar DP approach

## Complexity Analysis

### Time Complexity

- **Construction**: O(m×n) - fill entire DP table
- **Reconstruction**: O(m+n) - backtrack through table
- **Overall**: O(m×n)

### Space Complexity

- **Standard**: O(m×n) for DP table
- **Optimized**: O(min(m,n)) possible for length-only version

## Example Execution

```
Input:
  String 1: "ABCDGH"
  String 2: "AEDFHR"

Output:
  LCS Length: 3
  LCS String: "ADH"
```

## Implementation Notes

### Design Decisions

- **1-indexed Processing**: Adds space prefix for cleaner indexing
- **Separate Functions**: Length and string calculation in different functions
- **Backtracking Logic**: Careful navigation through DP table

### Potential Optimizations

- **Space Optimization**: Use only two rows for length calculation
- **Early Termination**: Stop if one string is exhausted
- **Memoization**: Alternative recursive approach with caching

## Tags

#dynamic-programming #string-algorithms #longest-common-subsequence #sequence-alignment #bioinformatics #text-processing

## Related Concepts

- [[Edit Distance (Levenshtein Distance)]]
- [[Longest Common Substring]]
- [[Dynamic Programming Principles]]
- [[String Matching Algorithms]]
- [[Sequence Alignment]]
- [[Diff Algorithms]]

## Overall Code

```cpp
/*
*
* Problem description:
* Implement the longest common subsequent problem algorithm.
*
*/
#include <iostream>
#include <vector>
#include <stdexcept> 
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <climits>
using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::priority_queue;
using std::unordered_map;
/************************* Declarations **************************/
/****************************************************************/
void get_string(string & inStr);
/////////////////////////////////////////////////////////////////////
int longestCommonSubsequenceNum(string text1, string text2);
/////////////////////////////////////////////////////////////////////
string longestCommonSubsequenceStr(string text1, string text2);
/*********************** Application ***************************/
/**************************************************************/
int main() 
{
    
    system("cls");
	
	string txt1{""};
	string txt2{""};
	int LCS_Num{0};
	string LCS_Str{""};
	
	cout << "\n Enter the first string: ";
	get_string(txt1);
	
	cout << "\n Enter the second string: ";
	get_string(txt2);
	
	LCS_Num = longestCommonSubsequenceNum(txt1, txt2);
	
	cout << "\n The longest common subsequence length is: " << LCS_Num ;
	
	LCS_Str = longestCommonSubsequenceStr(txt1, txt2);
	
	cout << "\n The longest common subsequence string is: " << LCS_Str ;
	
    return 0;
}
/********************* Function definitions *********************/
/****************************************************************/
void get_string(string & inStr)
{
    std::getline(cin, inStr);
}
/*---------------------------------------------------------------------------*/
int longestCommonSubsequenceNum(string text1, string text2)
{
	
	int result{0};
	int tx1Len{0};
	int tx2Len{0};
	
	tx1Len = text1.length();
	tx2Len = text2.length();
	
	text1 = " " + text1;
	text2 = " " + text2;
	
	vector<vector<int>> graph(tx2Len + 1, vector<int>(tx1Len + 1, 0));
	
	for(int i = 1; i <= tx2Len; ++i)
	{
		
		for(int j = 1; j <= tx1Len; ++j)
		{
			
			if(text2[i] == text1[j])
			{
				graph[i][j] = 1 + graph[i-1][j-1]; // 1 + top left corner
			}
			else
			{
				graph[i][j] = std::max(graph[i][j-1], graph[i-1][j]); // max(left, top)
			}
		}
		
	}
	
	result = graph[tx2Len][tx1Len];
	
	return result;
	
}
/*---------------------------------------------------------------------------*/
string longestCommonSubsequenceStr(string text1, string text2)
{
	
	string result{""};
	int tx1Len{0};
	int tx2Len{0};
	
	tx1Len = text1.length();
	tx2Len = text2.length();
	
	text1 = " " + text1;
	text2 = " " + text2;
	
	vector<vector<int>> graph(tx2Len + 1, vector<int>(tx1Len + 1, 0));
	
	for(int i = 1; i <= tx2Len; ++i)
	{
		
		for(int j = 1; j <= tx1Len; ++j)
		{
			
			if(text2[i] == text1[j])
			{
				graph[i][j] = 1 + graph[i-1][j-1]; // 1 + top left corner
			}
			else
			{
				graph[i][j] = std::max(graph[i][j-1], graph[i-1][j]); // max(left, top)
			}
		}
		
	}
	
	int i{tx2Len};
	int j{tx1Len};
	
	while(i > 0 && j > 0)
	{
		
		if(graph[i][j] > graph[i][j-1]) // Num in row > left
		{
			if(graph[i][j] == graph[i-1][j]) // Num in row == top
			{
				i--; // Move to the upper row
			}
			else
			{
				result = text2[i] + result;
				i--;
				j--;
			}
		}
		else
		{
			j--; // Move in the row tfrom right to left till hit a num > left 
		}
		
	}
	
	return result;
}
/****************************************************************/
/****************************************************************/
```
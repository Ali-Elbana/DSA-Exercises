
# Stagecoach Problem Algorithm - Dynamic Programming Implementation

## Problem Overview

The stagecoach problem is a classic **dynamic programming** optimization problem that finds the shortest path from a starting point to a destination through a series of stages, where movement is only allowed from earlier stages to later stages.

## Algorithm Description

This implementation uses **backward induction** (working from destination to source) to solve the stagecoach problem optimally.

### Key Characteristics

- **Problem Type**: Shortest path with stage constraints
- **Approach**: Dynamic programming (backward induction)
- **Time Complexity**: O(n²) where n is the number of nodes
- **Space Complexity**: O(n)

## Code Analysis

### Data Structures

```cpp
// Node labels A through J (10 stages)
vector<string> labels = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J"};

// Adjacency matrix representing the stagecoach network
// 0 = no direct connection, positive integers = travel costs
vector<vector<int>> graph = { /* 10x10 matrix */ };

// State structure to track optimal decisions
struct States {
    string from;  // Current node
    string to;    // Next optimal node
    int cost;     // Minimum cost from this node to destination
};
```

### Network Structure

The graph represents a **10-stage stagecoach network** (A → J):

- **Stage 1**: A (starting point)
- **Stages 2-4**: B, C, D (intermediate stops)
- **Stages 5-7**: E, F, G (intermediate stops)
- **Stages 8-9**: H, I (intermediate stops)
- **Stage 10**: J (destination)

### Algorithm Steps

#### 1. Initialization

```cpp
// Initialize destination node (J) with zero cost
vStates[n-1] = {"", "", 0};
```

#### 2. Backward Induction

```cpp
for(int i = n - 2; i >= 0; --i) {
    vStates[i] = {labels[i], "", INT_MAX};
    
    // Check all possible forward connections
    for(int j = i + 1; j < n; ++j) {
        if(graph[i][j] != 0) {
            new_cost = graph[i][j] + vStates[j].cost;
            
            // Update if better path found
            if(new_cost < vStates[i].cost) {
                vStates[i].cost = new_cost;
                vStates[i].to = labels[j];
            }
        }
    }
}
```

#### 3. Path Reconstruction

```cpp
// Build the optimal path by following 'to' pointers
while(i < n) {
    if(path[j] == vStates[i].from) {
        path.push_back(vStates[i].to);
        j++;
    }
    i++;
}
```

## Key Insights

### Why Backward Induction Works

- **Optimal Substructure**: The optimal path from any node depends only on optimal paths from subsequent nodes
- **No Cycles**: The stage constraint ensures no circular dependencies
- **Bellman's Principle**: We can solve smaller subproblems (later stages) first

### Dynamic Programming Properties

1. **Overlapping Subproblems**: Multiple paths may pass through the same intermediate nodes
2. **Optimal Substructure**: Optimal solution contains optimal solutions to subproblems
3. **Memoization**: Each node's optimal cost is computed once and reused

## Applications

- **Transportation Planning**: Actual stagecoach route optimization
- **Resource Allocation**: Multi-stage decision problems
- **Production Planning**: Sequential manufacturing decisions
- **Investment Strategy**: Multi-period portfolio optimization

## Complexity Analysis

- **Time**: O(n²) - nested loops over nodes
- **Space**: O(n) - storage for states and path
- **Optimality**: Guaranteed to find global optimum

## Example Output

```
Minimum Cost: [calculated optimal cost]
Minimum Path: A --> [intermediate nodes] --> J
```

----
## Overall Code

```cpp
/*
*
* Problem description:
* Implement the stagecoach problem algorithm.
*
*/
#include <iostream>
#include <vector>
#include <stdexcept> 
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>
#include <iomanip>
#include <climits>
using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::priority_queue;
using std::unordered_map;
/************************* Declarations **************************/
/****************************************************************/
vector<string> labels = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J"};
vector<vector<int>> graph = {
    {0, 2, 4, 3, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 7, 4, 6, 0, 0, 0},
    {0, 0, 0, 0, 3, 2, 4, 0, 0, 0},
    {0, 0, 0, 0, 4, 1, 5, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 1, 4, 0},
    {0, 0, 0, 0, 0, 0, 0, 6, 3, 0},
    {0, 0, 0, 0, 0, 0, 0, 3, 3, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 3},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 4},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};
struct States
{
	string from;
	string to;
	int cost;
};
/*********************** Application ***************************/
/**************************************************************/
int main() 
{
    
    system("cls");
	
	int n = graph.size();
	int new_cost{-1};
	vector<States> vStates(n);
	vector<string> path(1, labels[0]);
	
	vStates[n-1] = {"", "", 0};
	
	for(int i = n - 2; i >= 0; --i)
	{
		vStates[i] = {labels[i], "", INT_MAX};
		
		for(int j = i + 1; j < n; ++j)
		{
			if(graph[i][j] != 0)
			{
				new_cost = graph[i][j] + vStates[j].cost;
				
				if(new_cost < vStates[i].cost)
				{
					vStates[i].cost = new_cost;
					vStates[i].to = labels[j];
				}
			}
		}
	}
    
	// Get shortest path:
	int i{0}, j{0};
	
	while(i < n)
	{
		if(path[j] == vStates[i].from)
		{
			path.push_back(vStates[i].to);
			j++;
		}
		
		i++;
	}
	
	cout << "\nMinimum Cost: " << vStates[0].cost << endl;
	
	cout << "Minimum Path: ";
	
	for(int i = 0; i < path.size(); ++i)
	{
		cout << path[i];
		
		if(i <= (path.size() - 2))
		{
			cout << " --> ";
		}
	}
	
    return 0;
}
/****************************************************************/
/****************************************************************/
```

---
## Tags

#dynamic-programming #shortest-path #optimization #algorithms #graph-theory #backward-induction

---



**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=b48fd633-7c51-409e-9504-5f73d342fd55)

---
# 0/1 Knapsack Problem Algorithm

The 0/1 Knapsack problem is a classic optimization problem that involves selecting items to maximize their total profit, given a constraint on their total weight. The "0/1" signifies that for each item, you can either **include the entire item (1) or exclude it completely (0)**; you cannot take a fraction of an item.

This problem is typically solved using **Dynamic Programming**.

[![Knap01](G:\DSA\Slides\01Knapsack\s1.png)

---
## Problem Setup & Key Components

- **Items**: Each item has a `name`, `weight`, and `profit`.
    - Example items provided:
        - Item #1: 1 Kg weight, 4 profit ($)
        - Item #2: 3 Kg weight, 9 profit ($)
        - Item #3: 5 Kg weight, 12 profit ($)
        - Item #4: 4 Kg weight, 11 profit ($)
- **Maximum Weight (`max_weight` or `Wmax`)**: This is the capacity of the knapsack.
    - Example: A maximum weight of 8 Kg.
- **Dynamic Programming (DP) Table**: A 2D table (`dp` in the code, `table` in `main`) is used to store intermediate results.
    - **Initialization**: The table is typically initialized with `0`s. A "dummy item" with 0 weight and 0 profit (`Item("#0", 0, 0)`) is often added at the beginning of the items list to simplify DP table indexing.

[![Knap01](G:\DSA\Slides\01Knapsack\s2.png)

---
## Algorithm Steps [[6.3.2-  01 Knapsack Problem - Code#Complete Code Implementation]]

### 1. Building the DP Table

The core of the Dynamic Programming approach involves iterating through each item and each possible weight capacity up to `max_weight`. For each cell `dp[i][j]` (representing the maximum profit considering `i` items with a `j` weight capacity), the decision logic is as follows:

- **If the current item's `weight` (`items[i].weight`) is less than or equal to the current capacity `j`**:
    - You have two choices:
        1. **Include the current item**: The profit would be `items[i].profit` plus the maximum profit achievable from the remaining capacity (`j - items[i].weight`) using items _before_ the current one (`dp[i-1][j - items[i].weight]`).
        2. **Exclude the current item**: The profit would simply be the maximum profit achieved without the current item, using items _before_ it (`dp[i-1][j]`).
    - The cell `dp[i][j]` takes the **maximum of these two choices**: `std::max(dp[i-1][j], items[i].profit + dp[i-1][j - items[i].weight])`.
- **Else (if the current item's `weight` is greater than the current capacity `j`)**:
    - The item cannot be included, so the cell `dp[i][j]` simply takes the value from the cell above it (`dp[i-1][j]`), meaning the item is excluded.

This process fills the table row by row, column by column. The maximum profit for the given `max_weight` will be found at `dp[size - 1][max_weight]`.

[![Knap01](G:\DSA\Slides\01Knapsack\s4.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s5.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s6.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s7.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s8.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s9.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s10.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s11.png)

[![Knap01](G:\DSA\Slides\01Knapsack\s12.png)
### 2. Retrieving the Picked Items

After the DP table is filled, to find _which_ items were selected, you trace back from the bottom-right corner of the `dp` table (`dp[size - 1][max_weight]`).

The logic for backtracking is as follows:

- Start with `i` as the last item index (`size - 1`) and `j` as `max_weight`.
- While `remain >= 0`, `j > 0`, and `i > 0`:
    - **If `dp[i][j]` is greater than `dp[i-1][j]`**: This indicates that the current item (`items[i]`) contributed to the profit in `dp[i][j]`, meaning it was included in the solution.
        - Add `items[i].name` to the `solution` list.
        - Decrease `remain` by `items[i].weight`.
        - Decrement `i` and set `j` to the new `remain` (go to the column corresponding to the remaining weight and move to the top row).
    - **Else (`dp[i][j]` is equal to `dp[i-1][j]`)**: This means the current item was _not_ included to achieve this profit, so simply move to the previous item by decrementing `i`.

The `main` function then prints the `maxProfit` and the `solution` (picked items).

[![Knap01](G:\DSA\Slides\01Knapsack\s13.png)

---

**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=ba2765a8-2aff-4ed0-9cc2-ccea5afbb977)

---
## Longest Common Subsequence (LCS)

**The Longest Common Subsequence (LCS) problem** is a fundamental problem in computer science that involves finding the longest sequence of characters that appears in the same relative order in two (or more) strings, but not necessarily contiguously. This is an important distinction: it is **"Not substring"**. A subsequence can be derived from another sequence by deleting zero or more elements without changing the order of the remaining elements.

[![LCS](G:\DSA\Slides\LCS\s1.png)

---
### Problem Description

The core problem is to implement an algorithm to find the longest common subsequence between two given strings. This typically involves two main tasks:

1. **Determining the length** of the LCS.
2. **Constructing the actual LCS string**.

[![LCS](G:\DSA\Slides\LCS\s2.png)

[![LCS](G:\DSA\Slides\LCS\s3.png)

[![LCS](G:\DSA\Slides\LCS\s3.png)

[![LCS](G:\DSA\Slides\LCS\s4.png)

[![LCS](G:\DSA\Slides\LCS\s5.png)

[![LCS](G:\DSA\Slides\LCS\s6.png)

[![LCS](G:\DSA\Slides\LCS\s7.png)

----
### Key Concepts and Algorithm Overview

The provided solution for the LCS problem uses **Dynamic Programming**. This approach typically involves building up a solution from subproblems, often using a table or "graph" to store intermediate results and avoid redundant calculations.

The algorithm [[6.2.2-Longest Common Subsequent - Code#Overall Code]] uses a 2D integer `graph` (or table) to store the lengths of common subsequences. The dimensions of this `graph` are `(tx2Len + 1)` by `(tx1Len + 1)`, where `tx1Len` and `tx2Len` are the lengths of the input strings, `text1` and `text2`, respectively. The strings `text1` and `text2` are prepended with a space character (" ") to facilitate 1-based indexing when populating the `graph`.

**Rules for Populating the `graph` (Dynamic Programming Table):** The `graph` is filled iteratively, typically starting from `graph` up to `graph[tx2Len][tx1Len]`. For each cell `graph[i][j]`:

- **If the characters match** (`text2[i] == text1[j]`): The value of the current cell is `1` plus the value of the cell diagonally above and to the left (`graph[i-1][j-1]`). This means a new character has been added to the common subsequence.
    - `cell value = 1 + top_left_corner cell`
- **If the characters do not match** (`text2[i] != text1[j]`): The value of the current cell is the maximum of the value from the cell directly to its left (`graph[i][j-1]`) and the value from the cell directly above it (`graph[i-1][j]`). This indicates that the common subsequence length up to this point is determined by the longest common subsequence of the preceding parts of either string.
    - `cell value = Max(top cell, left cell)`
    - Where `top cell = table[i-1][j]` and `left cell = table[i, j-1]`.

[![LCS](G:\DSA\Slides\LCS\s13.png)

---
### Calculating the LCS Length (`longestCommonSubsequenceNum`)

The `longestCommonSubsequenceNum` function calculates the length of the LCS.

1. It initializes `tx1Len` and `tx2Len` with the lengths of `text1` and `text2`.
2. It prepends a space to both strings.
3. It initializes a `vector<vector<int>> graph` of size `(tx2Len + 1)` by `(tx1Len + 1)` with all values set to 0.
4. It then iterates through the `graph` using nested loops (from `i = 1` to `tx2Len` and `j = 1` to `tx1Len`) to populate each cell based on the matching rules described above.
5. The final length of the longest common subsequence is stored in `graph[tx2Len][tx1Len]`, which is then returned as the result.

[![LCS](G:\DSA\Slides\LCS\s14.png)

[![LCS](G:\DSA\Slides\LCS\s15.png)

[![LCS](G:\DSA\Slides\LCS\s16.png)

---
### Calculating the LCS String (`longestCommonSubsequenceStr`)

The `longestCommonSubsequenceStr` function reconstructs the actual LCS string.

1. It first performs the same steps as `longestCommonSubsequenceNum` to populate the `graph` table.
2. After the `graph` is fully populated, it **backtracks** from the bottom-right corner of the `graph` (starting at `i = tx2Len`, `j = tx1Len`).
3. The backtracking logic is as follows, continuing as long as `i > 0` and `j > 0`:
    - **If `graph[i][j]` is greater than `graph[i][j-1]`** (current value is not solely from the left cell):
        - **If `graph[i][j]` is also equal to `graph[i-1][j]`** (current value is equal to the top cell): This indicates the value propagated from the top, so move **up** (`i--`).
        - **Else** (if `graph[i][j]` is greater than `graph[i-1][j]`): This implies a match occurred at this cell, and the character `text2[i]` is part of the LCS. The character is prepended to the `result` string (`result = text2[i] + result`), and the algorithm moves **diagonally up-left** (`i--`, `j--`).
    - **Else** (if `graph[i][j]` is not greater than `graph[i][j-1]`, meaning `graph[i][j] == graph[i][j-1]`): This indicates the value propagated from the left cell, so move **left** (`j--`).
4. The loop continues until `i` or `j` becomes 0. The `result` string, built by prepending characters, will contain the LCS.

---

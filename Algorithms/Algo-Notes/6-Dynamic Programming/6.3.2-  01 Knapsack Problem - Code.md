# 0/1 Knapsack Problem Implementation

## Overview

**Algorithm**: Dynamic Programming solution for the 0/1 Knapsack Problem  
**Time Complexity**: O(n × W) where n = number of items, W = maximum weight  
**Space Complexity**: O(n × W) for the DP table  
**Tags**: #algorithms #dynamic-programming #optimization #knapsack

## Problem Statement

Given a set of items, each with a weight and profit value, determine the optimal combination of items to include in a knapsack with limited weight capacity to maximize total profit. Each item can only be selected once (0/1 constraint).

## Algorithm Explanation

### Core Logic

The algorithm uses a 2D DP table where `dp[i][j]` represents the maximum profit achievable using the first `i` items with a weight limit of `j`.

**Recurrence Relation**:

```
if (weight[i] <= j):
    dp[i][j] = max(dp[i-1][j], profit[i] + dp[i-1][j-weight[i]])
else:
    dp[i][j] = dp[i-1][j]
```

### Key Components

#### Item Structure

```cpp
struct Item {
    string name;
    int weight;
    int profit;
}
```

#### DP Table Construction

- **Rows**: Represent items (with dummy item at index 0)
- **Columns**: Represent weight capacities from 0 to max_weight
- **Base Case**: First row and column initialized to 0

#### Solution Reconstruction

Backtracking through the DP table to identify selected items:

- If `dp[i][j] > dp[i-1][j]`: item `i` was selected
- Update remaining capacity and continue

## Implementation Details

### Test Case

- **Max Weight**: 8
- **Items**:
    - Item #1: weight=1, profit=4
    - Item #2: weight=3, profit=9
    - Item #3: weight=5, profit=12
    - Item #4: weight=4, profit=11

### Expected Output

- **Maximum Profit**: 24
- **Selected Items**: [#4, #2, #1] (weight: 4+3+1=8, profit: 11+9+4=24)

## Complete Code Implementation

```cpp
/*
*
* Problem description:
* Implement the 0/1 Knapsack problem algorithm.
*
*/

#include <iostream>
#include <vector>
#include <stdexcept> 
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>

#include <iomanip>
#include <climits>

using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::priority_queue;
using std::unordered_map;

/************************* Declarations **************************/
/****************************************************************/

struct Item
{
	string name;
	int weight;
	int profit;
	
	// Constructor
	Item(string str, int w, int p): name(str), weight(w), profit(p) {}
	
};
/////////////////////////////////////////////////////////////////////

int knapsack(vector<Item> &items, int max_weight, vector<vector<int>> &dp,
             vector<string> &solution);
/*********************** Application ***************************/
/**************************************************************/

int main() 
{
    
    system("cls");
	
	int maxWeight{8};
	vector<string> solution;
	int maxProfit{-1};
	
	vector<Item> items =
	{
		Item("#1", 1, 4),
        Item("#2", 3, 9),
        Item("#3", 5, 12),
        Item("#4", 4, 11)
	};
	
	// Add dummy item at the beginning
	items.insert(items.begin(), Item("#0", 0, 0));
	
	// Initialize DP table
	vector<vector<int>> table(items.size(), vector<int>(maxWeight + 1, 0));
	
	maxProfit = knapsack(items, maxWeight, table, solution);
	
	cout << "\n The max profit is: " <<  maxProfit;
	cout << "\n The picked items are: [ ";
	
	for(auto & str : solution)
	{
		cout << str << " ";
	}
	
	cout << "]\n";
	
    return 0;

}
/********************* Function definitions *********************/
/****************************************************************/

int knapsack(vector<Item> &items, int max_weight, vector<vector<int>> &dp,
             vector<string> &solution)
{

	int size = items.size();
	int max_profit{-1};
	
	// To establish the table:
	/* if item weight <= current weight (j weight)
		-- max(top cell, profit + table[top cell][diff of weights])
		--> == max(table[i-1][j], profit + table[i-1][j-w])

	   else
		-- top cell == table[i-1][j]
	*/
	for(int i = 1; i < size; ++i)
	{
		for(int j = 1; j <= max_weight; ++j)
		{
			if(items[i].weight <= j)
			{
				dp[i][j] = std::max(dp[i-1][j], items[i].profit + 
												dp[i-1][j - items[i].weight]);
			}
			else
			{
				dp[i][j] = dp[i-1][j];
			}
			
		}
	}
	
	max_profit = dp[size - 1][max_weight];
	
	// Get the items:
	// Start from the bottom right
	int i = size - 1;
	int j = max_weight;
	int remain = max_weight;
	
	while(remain >= 0 && j > 0 && i > 0)
	{
		if(dp[i][j] > dp[i-1][j]) // current value > profit
		{
			solution.push_back(items[i].name);
			remain -= items[i].weight;
			i--;
			j = remain;
		}
		else
		{
			i--;
		}
	}
	
	return max_profit;

}	 
/****************************************************************/
/****************************************************************/
```

## Code Structure

### Main Function

1. Initialize items and DP table
2. Call knapsack function
3. Display results

### Knapsack Function

1. **Fill DP Table**: Iterate through items and weights
2. **Extract Solution**: Backtrack to find selected items
3. **Return**: Maximum profit

## Key Observations

### Strengths

- ✅ Correct DP formulation
- ✅ Proper solution reconstruction
- ✅ Clear item structure
- ✅ Handles edge cases with dummy item

### Areas for Improvement

- **Memory Optimization**: Could use 1D array (space complexity O(W))
- **Input Validation**: No bounds checking for weights/profits
- **Platform Dependency**: `system("cls")` is Windows-specific
- **Code Organization**: Could separate I/O from algorithm logic

## Complexity Analysis

| Aspect              | Complexity |
| ------------------- | ---------- |
| Time                | O(n × W)   |
| Space               | O(n × W)   |
| Fill DP Table       | O(n × W)   |
| Solution Extraction | O(n)       |


---

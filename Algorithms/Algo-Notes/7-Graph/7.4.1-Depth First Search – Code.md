# Depth-First Search (DFS) - Recursive Implementation

## Overview

**Algorithm**: Depth-First Search (Recursive Graph Traversal)  
**Time Complexity**: O(V + E) where V = vertices, E = edges  
**Space Complexity**: O(V) for recursion stack + visited array  
**Tags**: #algorithms #graph-theory #traversal #depth-first-search #recursion #call-stack

## Problem Statement

Given a graph represented as an adjacency list, implement the Depth-First Search algorithm using recursion to traverse all reachable nodes by exploring as far as possible along each branch before backtracking. This approach uses the system call stack instead of an explicit stack data structure.

## Algorithm Explanation

### Core Principle

Recursive DFS uses the **system call stack** to maintain traversal state:

1. **Mark** current node as visited
2. **For each unvisited neighbor**:
    - Print the edge being traversed
    - **Recursively call** DFS on the neighbor
3. **Backtrack** automatically when function returns

### Key Properties

- **Depth-first exploration**: Goes as deep as possible before backtracking
- **Implicit stack**: Uses function call stack instead of explicit data structure
- **Natural backtracking**: Function returns provide automatic backtracking
- **Elegant code**: Minimal lines compared to iterative approaches

## Complete Code Implementation

```cpp
/*
*
* Problem description:
* Implement the Depth First Search algorithm using recursion.
*
*/
#include <iostream>
#include <vector>
#include <stdexcept> 
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>
#include <iomanip>
#include <climits>

using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::queue;
using std::priority_queue;
using std::unordered_map;

/************************* Declarations **************************/
/****************************************************************/

class Graph
{
	private:
	vector<string> nodeNames;
	vector<vector<int>> adjacencyList;
	vector<bool> isVisited;  // <- MOVED: Make visited array a class member
	
	// <- ADD: Private recursive helper function
	void DFS_Recursive(int currentNode)
	{
		// Mark current node as visited
		isVisited[currentNode] = true;
		
		// Visit all unvisited neighbors
		for(int neighbor : adjacencyList[currentNode])
		{
			if(isVisited[neighbor] == false)
			{
				// Print the edge being traversed
				cout << ' ' << nodeNames[currentNode] << " - " << nodeNames[neighbor] << endl;
				
				// Recursively visit the neighbor
				DFS_Recursive(neighbor);  // <- RECURSIVE CALL
			}
		}
	}
	
	public:
	// Constructor - create graph with node names
	Graph(vector<string> & nNames)
	{
		nodeNames = nNames;
		adjacencyList.resize(nodeNames.size());
	}
	
	// Add edges for a node
	void addEdges(int nodeIdx, vector<int> connections)
	{
		adjacencyList[nodeIdx] = connections;
	}
	
	// <- SIMPLIFIED: Public DFS method (no loops, no stacks!)
    void DFS() 
	{
        cout << "\n DFS Traversal (Recursive):\n";
		
		int numNodes = nodeNames.size();
		
		// Initialize visited array
		isVisited.assign(numNodes, false);
		
		// Start recursive DFS from node 0
		DFS_Recursive(0);  // <- SINGLE FUNCTION CALL!
	}
};

/*********************** Application ***************************/
/**************************************************************/

int main() 
{
    
    system("cls");
	
	// Create graph with same nodes as original
    vector<string> names{"A", "B", "C", "D", "E", "F", "G", "H", "I"};
	
	Graph g(names);
	
	// Add same edges as original
    g.addEdges(0, {1, 2});        // A connects to B, C
    g.addEdges(1, {0, 3, 4});     // B connects to A, D, E
    g.addEdges(2, {0, 3, 5});     // C connects to A, D, F
    g.addEdges(3, {1, 2, 4});     // D connects to B, C, E
    g.addEdges(4, {1, 5});        // E connects to B, F
    g.addEdges(5, {2, 3, 4, 7});  // F connects to C, D, E, H
    g.addEdges(6, {7, 8});        // G connects to H, I
    g.addEdges(7, {5, 6, 8});     // H connects to F, G, I
    g.addEdges(8, {6, 7});        // I connects to G, H
	
	g.DFS();
	
    return 0;
}

/********************* Function definitions *********************/
/****************************************************************/
/****************************************************************/
/****************************************************************/
```

## Implementation Details

### Graph Structure

The graph consists of **9 nodes** labeled A through I:

```
Indices: 0, 1, 2, 3, 4, 5, 6, 7, 8
Labels:  A, B, C, D, E, F, G, H, I
```

### Graph Visualization

```
Component 1 (Connected):        Component 2 (Isolated):
    A ---- B ---- D                    G ---- I
    |      |      |                    |      |
    |      |      |                    |      |
    C ---- F ---- E                    H ------+
           |
           |
           H (connects to G-I)
```

**Adjacency List Representation**:

- **A(0)**: [B(1), C(2)]
- **B(1)**: [A(0), D(3), E(4)]
- **C(2)**: [A(0), D(3), F(5)]
- **D(3)**: [B(1), C(2), E(4)]
- **E(4)**: [B(1), F(5)]
- **F(5)**: [C(2), D(3), E(4), H(7)]
- **G(6)**: [H(7), I(8)]
- **H(7)**: [F(5), G(6), I(8)]
- **I(8)**: [G(6), H(7)]

## Algorithm Walkthrough

### Recursive Call Stack Execution

**Starting from A(0):**

```
Call Stack Depth 1: DFS_Recursive(A)
├─ Mark A as visited
├─ A → B (first unvisited neighbor)
│   └─ Call Stack Depth 2: DFS_Recursive(B)
│       ├─ Mark B as visited
│       ├─ B → D (first unvisited neighbor, skip A - visited)
│       │   └─ Call Stack Depth 3: DFS_Recursive(D)
│       │       ├─ Mark D as visited
│       │       ├─ D → C (first unvisited neighbor, skip B - visited)
│       │       │   └─ Call Stack Depth 4: DFS_Recursive(C)
│       │       │       ├─ Mark C as visited
│       │       │       ├─ C → F (first unvisited neighbor, skip A,D - visited)
│       │       │       │   └─ Call Stack Depth 5: DFS_Recursive(F)
│       │       │       │       ├─ Mark F as visited
│       │       │       │       ├─ F → E (first unvisited neighbor, skip C,D - visited)
│       │       │       │       │   └─ Call Stack Depth 6: DFS_Recursive(E)
│       │       │       │       │       ├─ Mark E as visited
│       │       │       │       │       ├─ All neighbors visited (B,F)
│       │       │       │       │       └─ RETURN (backtrack)
│       │       │       │       ├─ F → H (next unvisited neighbor)
│       │       │       │       │   └─ Call Stack Depth 6: DFS_Recursive(H)
│       │       │       │       │       ├─ Mark H as visited
│       │       │       │       │       ├─ H → G (first unvisited neighbor, skip F - visited)
│       │       │       │       │       │   └─ Call Stack Depth 7: DFS_Recursive(G)
│       │       │       │       │       │       ├─ Mark G as visited
│       │       │       │       │       │       ├─ G → I (first unvisited neighbor, skip H - visited)
│       │       │       │       │       │       │   └─ Call Stack Depth 8: DFS_Recursive(I)
│       │       │       │       │       │       │       ├─ Mark I as visited
│       │       │       │       │       │       │       ├─ All neighbors visited (G,H)
│       │       │       │       │       │       │       └─ RETURN
│       │       │       │       │       │       └─ RETURN
│       │       │       │       │       ├─ All neighbors visited (F,G,I)
│       │       │       │       │       └─ RETURN
│       │       │       │       └─ RETURN
│       │       │       └─ RETURN
│       │       ├─ D → E (already visited, skip)
│       │       └─ RETURN
│       ├─ B → E (already visited, skip)
│       └─ RETURN
├─ A → C (already visited, skip)
└─ RETURN (DFS Complete)
```

### Expected Output

```
DFS Traversal (Recursive):
 A - B
 B - D
 D - C
 C - F
 F - E
 F - H
 H - G
 G - I
```

## Code Architecture Analysis

### Class Design

|Component|Type|Scope|Purpose|
|---|---|---|---|
|`nodeNames`|`vector<string>`|Private|Store vertex labels|
|`adjacencyList`|`vector<vector<int>>`|Private|Store graph connections|
|`isVisited`|`vector<bool>`|Private|**Class member** for shared state|
|`DFS_Recursive()`|Method|Private|**Recursive helper** function|
|`DFS()`|Method|Public|**Public interface** initialization|

### Key Design Decisions

#### **Class Member `isVisited`**

```cpp
vector<bool> isVisited;  // Class member - accessible to all methods
```

**Why class member instead of local variable?**

- **Shared State**: All recursive calls need access to visited array
- **No Parameter Passing**: Cleaner interface without passing `visited` to each call
- **Encapsulation**: Keeps traversal state within the Graph class

#### **Private Recursive Helper**

```cpp
void DFS_Recursive(int currentNode)  // Private helper
```

**Benefits:**

- **Clean Public Interface**: `DFS()` is simple one-line call
- **Implementation Hiding**: Recursive details hidden from user
- **Initialization Separation**: Public method handles setup, private method handles logic

## Complexity Analysis

|Aspect|Complexity|Explanation|
|---|---|---|
|**Time**|O(V + E)|Visit each vertex once + examine each edge once|
|**Space**|O(V)|Visited array + recursion stack depth|
|**Recursion Depth**|O(V) worst case|Linear path through all vertices|
|**Call Stack Memory**|O(V)|Each recursive call uses stack frame|

### **Space Breakdown:**

- **Visited Array**: O(V) - Boolean flag for each vertex
- **Call Stack**: O(V) - Maximum depth in worst case (linear graph)
- **Total Space**: O(V) + O(V) = O(V)

## Comparison: Recursive vs Iterative DFS

|Feature|Recursive DFS|Iterative DFS (Stack)|
|---|---|---|
|**Code Lines**|~8 lines core logic|~15 lines core logic|
|**Readability**|✅ **Very Clean**|Medium complexity|
|**Stack Management**|✅ **Automatic**|Manual push/pop|
|**Memory Usage**|Call stack|Explicit stack|
|**Stack Overflow Risk**|⚠️ **Yes (deep graphs)**|✅ **Controlled**|
|**Debugging**|Harder to trace|Easier to step through|
|**Performance**|Slight overhead|Slightly faster|

## Advantages & Disadvantages

### **✅ Advantages:**

- **Elegant Code**: Natural and intuitive implementation
- **Less Error-Prone**: No manual stack management
- **Mathematical Beauty**: Directly reflects recursive definition
- **Automatic Backtracking**: Function returns provide natural backtracking
- **Shorter Code**: Minimal lines of code required

### **❌ Disadvantages:**

- **Stack Overflow**: Deep graphs can exhaust call stack
- **Memory Overhead**: Function call overhead per recursion
- **Limited Control**: Can't easily pause/resume traversal
- **Debugging Difficulty**: Stack trace can be complex

### **Stack Overflow Example:**

```cpp
// Problematic for very deep graphs:
// A → B → C → D → ... → Z (1000+ nodes in chain)
// Each recursive call adds to system stack
// Eventually: Stack Overflow Exception
```

## Applications of Recursive DFS

- **Maze Solving**: Finding paths through mazes
- **Tree Traversal**: In-order, pre-order, post-order traversals
- **Topological Sorting**: Ordering dependent tasks
- **Cycle Detection**: Finding cycles in graphs
- **Connected Components**: Finding disconnected parts
- **Path Finding**: Finding any path between nodes
- **Backtracking Algorithms**: N-Queens, Sudoku solving

## Best Practices

### **When to Use Recursive DFS:**

- ✅ **Small to Medium Graphs**: Avoid stack overflow
- ✅ **Learning/Teaching**: Most intuitive approach
- ✅ **Interview Coding**: Clean and impressive
- ✅ **Prototype Development**: Quick implementation

### **When to Use Iterative DFS:**

- ✅ **Large/Deep Graphs**: Avoid stack overflow
- ✅ **Production Systems**: More predictable memory usage
- ✅ **Memory-Constrained**: Control stack size
- ✅ **Real-time Systems**: Avoid unpredictable call depths

## Practice Problems

- LeetCode 200: Number of Islands (DFS Application)
- LeetCode 695: Max Area of Island
- LeetCode 733: Flood Fill
- LeetCode 79: Word Search (Backtracking + DFS)
- LeetCode 130: Surrounded Regions
- LeetCode 417: Pacific Atlantic Water Flow

## Variations

- **DFS with Path Tracking**: Store the actual path taken
- **DFS with Timestamps**: Record discovery/finish times
- **DFS for Cycle Detection**: Detect back edges
- **DFS for Topological Sort**: Order vertices by finish time
- **Multi-source DFS**: Start from multiple nodes

---

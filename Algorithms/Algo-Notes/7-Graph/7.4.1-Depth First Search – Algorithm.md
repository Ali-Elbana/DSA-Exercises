
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=0d259443-a5a9-4ae7-b4c1-35ec09835f56)

---
## Introduction

The **Depth First Search (DFS)** algorithm is a fundamental **graph traversal algorithm**. Its primary method involves exploring as far as possible along each branch of a graph before it "backtracks" [The recursive nature described in and the visual trace support this].

[![DFS](G:\DSA\Slides\DFS\s1.png)

[![DFS](G:\DSA\Slides\DFS\s2.png)

[![DFS](G:\DSA\Slides\DFS\s3.png)

[![DFS](G:\DSA\Slides\DFS\s4.png)

[![DFS](G:\DSA\Slides\DFS\s5.png)

[![DFS](G:\DSA\Slides\DFS\s6.png)

[![DFS](G:\DSA\Slides\DFS\s7.png)

[![DFS](G:\DSA\Slides\DFS\s8.png)

[![DFS](G:\DSA\Slides\DFS\s9.png)

[![DFS](G:\DSA\Slides\DFS\s10.png)

[![DFS](G:\DSA\Slides\DFS\s11.png)

[![DFS](G:\DSA\Slides\DFS\s12.png)

[![DFS](G:\DSA\Slides\DFS\s13.png)

[![DFS](G:\DSA\Slides\DFS\s14.png)

[![DFS](G:\DSA\Slides\DFS\s15.png)

[![DFS](G:\DSA\Slides\DFS\s16.png)

[![DFS](G:\DSA\Slides\DFS\s17.png)

[![DFS](G:\DSA\Slides\DFS\s18.png)

[![DFS](G:\DSA\Slides\DFS\s19.png)

[![DFS](G:\DSA\Slides\DFS\s20.png)

[![DFS](G:\DSA\Slides\DFS\s21.png)

[![DFS](G:\DSA\Slides\DFS\s22.png)

[![DFS](G:\DSA\Slides\DFS\s23.png)

---
## Recursive Implementation in C++ (from source)

The provided C++ code [[7.4.1-Depth First Search â€“ Code#Complete Code Implementation]] implements DFS using recursion. This approach simplifies the public interface, as explicit loops or stacks are not needed in the `DFS()` method; recursion implicitly handles the depth-first exploration and backtracking.

---
### Graph Class Structure

The `Graph` class is designed to represent the graph and manage the traversal state:

- **`nodeNames`**: A `vector<string>` that stores the names of the nodes in the graph (e.g., "A", "B", "C").
- **`adjacencyList`**: A `vector<vector<int>>` that represents the connections between nodes. Each element `adjacencyList[i]` contains a list of integers, where each integer is the index of a node directly connected to node `i`.
- **`isVisited`**: A `vector<bool>` that keeps track of which nodes have been visited during the current DFS traversal. It's a private class member, allowing its state to be managed across recursive calls.

---
### Key Methods

#### `Graph(vector<string> & nNames)` (Constructor)

- Initializes the `nodeNames` member with the provided vector of strings.
- Resizes the `adjacencyList` to match the total number of nodes in the graph.

#### `addEdges(int nodeIdx, vector<int> connections)`

- This method is used to define the connections (edges) for a specific node. It takes a node's index (`nodeIdx`) and a vector of integers representing the indices of nodes it connects to, and populates the `adjacencyList` accordingly.

#### `DFS()` (Public Method)

- This is the public entry point for initiating the Depth First Search traversal.
- It first prints a header: `" DFS Traversal (Recursive):"`.
- It determines the total number of nodes.
- It **initializes the `isVisited` array**, setting all nodes to `false` (unvisited) to prepare for a new traversal.
- Finally, it makes a **single function call** to the private recursive helper `DFS_Recursive(0)`, starting the traversal from node 0 (which corresponds to node "A" in the example graph).

#### `DFS_Recursive(int currentNode)` (Private Recursive Helper Function)

- This is the **core recursive function** that performs the depth-first exploration.
- When called for a `currentNode`, it first **marks the `currentNode` as visited** by setting `isVisited[currentNode] = true`.
- It then iterates through all `neighbor` nodes connected to the `currentNode` via its `adjacencyList`.
- For each `neighbor`, it checks if that neighbor has **not been visited** (`isVisited[neighbor] == false`).
- If a neighbor is unvisited:
    - It prints the edge being traversed, showing the connection (e.g., `" A - B"`).
    - It then makes a **recursive call to `DFS_Recursive(neighbor)`**, effectively diving deeper into the graph from that unvisited neighbor.


---
## Example Graph and Traversal Trace (from C++ code and visual representation)

The provided C++ example creates a graph with nine nodes labeled "A" through "I". The connections (edges) are defined as follows:

- **A** connects to **B, C**
- **B** connects to **A, D, E**
- **C** connects to **A, D, F**
- **D** connects to **B, C, E**
- **E** connects to **B, F**
- **F** connects to **C, D, E, H**
- **G** connects to **H, I**
- **H** connects to **F, G, I**
- **I** connects to **G, H**

The `main` function starts the DFS traversal from node 'A' (node 0). The visual trace provides a step-by-step illustration of the traversal, where:

- **Yellow** nodes indicate the node currently being visited or on the active path of exploration.
- **Dark Grey** nodes indicate nodes that have been visited and from which all reachable unvisited paths have been explored (i.e., the recursive call for that node has returned).
- **White** nodes are those that have not yet been visited.

---
### Illustrative Traversal Steps:

1. Initially, all nodes are white.
2. The DFS begins at **A** (becomes yellow). It marks A as visited. It finds B as an unvisited neighbor. Prints "A - B". Recursively calls DFS for B.
3. **B** (yellow) is marked visited. It finds D as unvisited. Prints "B - D". Recursively calls DFS for D.
4. **D** (yellow) is marked visited. It finds C as unvisited. Prints "D - C". Recursively calls DFS for C.
5. **C** (yellow) is marked visited. It finds F as unvisited. Prints "C - F". Recursively calls DFS for F.
6. **F** (yellow) is marked visited. It finds H as unvisited. Prints "F - H". Recursively calls DFS for H.
7. **H** (yellow) is marked visited. It finds G as unvisited. Prints "H - G". Recursively calls DFS for G.
8. **G** (yellow) is marked visited. It finds I as unvisited. Prints "G - I". Recursively calls DFS for I.
9. **I** (yellow) is marked visited. I has no unvisited neighbors. The recursive call for I completes, and it backtracks. I becomes dark grey.
10. The recursive call for **G** completes (all its neighbors explored). G backtracks and becomes dark grey.
11. The recursive call for **H** completes (all its neighbors explored). H backtracks and becomes dark grey.
12. Back at **F** (now dark grey, but active as its recursive call has not finished), it finds E as an unvisited neighbor (it had already explored C, D, H through recursive calls). Prints "F - E". Recursively calls DFS for E.
13. **E** (yellow) is marked visited. E has no unvisited neighbors. The recursive call for E completes, and it backtracks. E becomes dark grey.
14. The recursive call for **F** completes (all its neighbors explored). F backtracks and becomes dark grey.
15. The recursive call for **C** completes. C backtracks and becomes dark grey.
16. The recursive call for **D** completes. D backtracks and becomes dark grey.
17. The recursive call for **B** completes. B backtracks and becomes dark grey.
18. The recursive call for **A** completes. A backtracks and becomes dark grey.

This sequence clearly illustrates the "depth-first" nature of the algorithm: it thoroughly explores one path (e.g., A -> B -> D -> C -> F -> H -> G -> I) before returning to previous nodes and exploring alternative branches (like F -> E). Since the entire graph is a single connected component, starting from node A (node 0) successfully visits all nodes.

[![DFS](G:\DSA\Slides\DFS\s24.png)

---

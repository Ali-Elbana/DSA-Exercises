
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=e236add0-9d8f-4f10-a6b3-76f31d5a1140)

---
## What is Breadth-First Search (BFS)?

Breadth-First Search (BFS) is a fundamental **graph traversal algorithm**. Its primary purpose is to systematically explore all the nodes in a graph. The name "Breadth-First" implies that the algorithm explores nodes **layer by layer**, visiting all nodes at the current "depth" level before proceeding to the next level of neighbors. The term "breadth" itself refers to the distance across an object, especially its shorter dimension.

The specific problem addressed by the provided C++ implementation is to **implement the Breadth First Search algorithm**.

[![BFS](G:\DSA\Slides\BFS\s1.png)

[![BFS](G:\DSA\Slides\BFS\s2.png)

---
## How BFS Works

BFS operates by exploring a graph in a level-by-level fashion, starting from a designated source node. It leverages a **queue** data structure to manage the order of node visitation, ensuring that all direct neighbors of a currently visited node are explored before moving to their neighbors.

Here is a detailed breakdown of the algorithm's steps, as implemented in the provided C++ code:

1. **Initialization**:
    
    - A `vector<bool>` named `isVisited` is created, with its size matching the total number of nodes in the graph. All entries are initially set to `false`, indicating that no nodes have been visited yet. This array is crucial for preventing infinite loops in cyclic graphs and avoiding redundant processing of nodes.
    - A `queue<int>` named `trackConnectionsQue` is initialized. This queue will store the indices of nodes that are queued for future visitation.
    - The algorithm begins by selecting an arbitrary starting node. In the example, node 0 (corresponding to "A") is chosen. Its index is pushed into `trackConnectionsQue`.
    - The starting node is immediately marked as visited by setting its corresponding entry in `isVisited` to `true` (`isVisited = true`).
2. **Traversal Loop**:
    
    - The core of the BFS algorithm is a `while` loop that continues as long as `trackConnectionsQue` is not empty. This condition ensures that all reachable nodes are eventually processed.
    - Inside the loop, for each iteration:
        - **Dequeue Current Node**: The node at the front of the `trackConnectionsQue` is retrieved (`trackConnectionsQue.front()`) and then removed (`trackConnectionsQue.pop()`). This node becomes the `currentNode` for the current iteration.
        - **Explore Neighbors**: The algorithm then iterates through all the direct `connection`s (neighbors) of the `currentNode`. These connections are retrieved from the graph's `adjacencyList` (`adjacencyList[currentNode]`).
        - **Visit Unvisited Neighbors**: For each `connection`:
            - **Check Visited Status**: It first checks if the `connection` has already been visited (`if(isVisited[connection] == false)`).
            - **Enqueue and Mark**: If the `connection` is unvisited, its index is added to the `trackConnectionsQue` (`trackConnectionsQue.push(connection)`). Subsequently, `isVisited[connection]` is set to `true` to mark it as visited.
            - **Record Traversal**: The specific edge being traversed (e.g., "A - B") is printed to the console (`cout << ' ' << nodeNames[currentNode] << " - " << nodeNames[connection] << endl;`).

The algorithm concludes when the `trackConnectionsQue` becomes empty, signifying that all reachable nodes and their connections have been explored.

[![BFS](G:\DSA\Slides\BFS\s3.png)

[![BFS](G:\DSA\Slides\BFS\s4.png)

[![BFS](G:\DSA\Slides\BFS\s5.png)

[![BFS](G:\DSA\Slides\BFS\s6.png)

[![BFS](G:\DSA\Slides\BFS\s7.png)

[![BFS](G:\DSA\Slides\BFS\s8.png)

[![BFS](G:\DSA\Slides\BFS\s9.png)

[![BFS](G:\DSA\Slides\BFS\s10.png)

[![BFS](G:\DSA\Slides\BFS\s11.png)

[![BFS](G:\DSA\Slides\BFS\s12.png)

[![BFS](G:\DSA\Slides\BFS\s13.png)

[![BFS](G:\DSA\Slides\BFS\s14.png)

[![BFS](G:\DSA\Slides\BFS\s15.png)

[![BFS](G:\DSA\Slides\BFS\s16.png)

[![BFS](G:\DSA\Slides\BFS\s17.png)

---
## C++ Implementation Details

The provided code [[7.3.2-Breadth First Search â€“ Code#Complete Code Implementation]] implements the BFS algorithm in C++.

- **Standard Libraries**: It utilizes standard C++ libraries such as `<iostream>` for input/output, `<vector>` for dynamic arrays (used for `nodeNames` and `adjacencyList`), `<queue>` for the core BFS queue, and `<string>` for node names.
- **`Graph` Class**: A `Graph` class encapsulates the graph's structure and BFS functionality.
    - **Data Members**:
        - `nodeNames`: A `vector<string>` holds the human-readable names of the nodes, such as "A", "B", "C".
        - `adjacencyList`: A `vector<vector<int>>` is used to represent the graph's connections. Each inner `vector<int>` at `adjacencyList[i]` stores the indices of nodes directly connected to node `i`.
    - **Constructor**: The `Graph` constructor takes a `vector<string>` of node names and initializes the `nodeNames` member, also resizing the `adjacencyList` to match the number of nodes.
    - **`addEdges(int nodeIdx, vector<int> connections)`**: This public method is used to define the edges for a specific node (`nodeIdx`) by assigning its connections to the corresponding entry in `adjacencyList`.
    - **`BFS()` Method**: This public method contains the entire BFS traversal logic, as detailed in the "How BFS Works" section.

**Example Graph Used in Code:** The `main()` function within the C++ code demonstrates BFS using a specific graph composed of 9 nodes, labeled 'A' through 'I'.

- The nodes are defined as `vector<string> names{"A", "B", "C", "D", "E", "F", "G", "H", "I"};`.
- The connections (edges) are explicitly defined using `g.addEdges()` calls, forming the graph's structure. For instance:
    - Node 'A' (index 0) connects to 'B' (1) and 'C' (2).
    - Node 'B' (index 1) connects to 'A' (0), 'D' (3), and 'E' (4).
    - Node 'F' (index 5) connects to 'C' (2), 'D' (3), 'E' (4), and 'H' (7).
    - The full graph's adjacency list representation is also visually presented.

[![BFS](G:\DSA\Slides\BFS\s19.png)

[![BFS](G:\DSA\Slides\BFS\s20.png)

[![BFS](G:\DSA\Slides\BFS\s21.png)

[![BFS](G:\DSA\Slides\BFS\s22.png)

[![BFS](G:\DSA\Slides\BFS\s23.png)

[![BFS](G:\DSA\Slides\BFS\s24.png)

---
## Visual Progression (Example Walkthrough)

The provided images visually trace the execution of the BFS algorithm on the example graph.

- **Initial State**: The graph begins with all nodes (A-I) and their connections visible.
- **Start**: Node 'A' is selected as the starting point. It is marked as visited and placed into the queue.
- **First Level Traversal**:
    - 'A' is dequeued. Its unvisited direct neighbors, 'B' and 'C', are identified.
    - 'B' and 'C' are then enqueued and marked as visited. The edges A-B and A-C are part of the traversal. At this stage, the queue holds 'B' then 'C'. In the visual representation, 'A' might become dark gray (processed), while 'B' and 'C' become yellow (enqueued/newly visited).
- **Second Level Traversal**:
    - 'B' is dequeued. Its unvisited neighbors, 'D' and 'E', are identified (as 'A' is already visited).
    - 'D' and 'E' are enqueued and marked visited. The edges B-D and B-E are traversed. The queue now holds 'C', 'D', 'E'. 'B' transitions to dark gray, while 'D' and 'E' become yellow.
- **Third Level Traversal**:
    - 'C' is dequeued. Its unvisited neighbor, 'F', is identified (as 'A' and 'D' are already visited).
    - 'F' is enqueued and marked visited. The edge C-F is traversed. The queue now contains 'D', 'E', 'F'. 'C' becomes dark gray, and 'F' becomes yellow.
- This methodical process continues, with the algorithm systematically visiting all nodes at the current level before moving to deeper levels. Yellow highlighting in the images typically signifies nodes that are currently in the queue or edges that have just been traversed, while dark gray nodes indicate those that have been fully processed. The final image illustrates the complete set of edges traversed, which form the BFS tree (or forest, if the graph is disconnected).

| Step | Queue State | Current Node | Visited                     | Action                   |
| ---- | ----------- | ------------ | --------------------------- | ------------------------ |
| 1    | [A]         | -            | [A]                         | Initialize with A        |
| 2    | [B, C]      | A            | [A]                         | Process A, add B, C      |
| 3    | [C, D, E]   | B            | [A, B]                      | Process B, add D, E      |
| 4    | [D, E, F]   | C            | [A, B, C]                   | Process C, add F         |
| 5    | [E, F]      | D            | [A, B, C, D]                | Process D (no new nodes) |
| 6    | [F]         | E            | [A, B, C, D, E]             | Process E (no new nodes) |
| 7    | [H]         | F            | [A, B, C, D, E, F]          | Process F, add H         |
| 8    | [G, I]      | H            | [A, B, C, D, E, F, H]       | Process H, add G, I      |
| 9    | [I]         | G            | [A, B, C, D, E, F, H, G]    | Process G (no new nodes) |
| 10   | []          | I            | [A, B, C, D, E, F, H, G, I] | Process I (no new nodes) |

---


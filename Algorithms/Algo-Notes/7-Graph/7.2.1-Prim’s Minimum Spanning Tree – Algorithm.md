**Video explanation by AI:** [Watch the video here]()

---
# Prim's Minimum Spanning Tree Algorithm

Prim's Algorithm is a **greedy algorithm** used to find a **Minimum Spanning Tree (MST)** for a **weighted, undirected graph**. The problem it solves is to implement this algorithm.

[![PMST](G:\DSA\Slides\PMST\s5.png)

---
## What is a Minimum Spanning Tree (MST)?

A Spanning Tree of a connected, undirected graph is a subgraph that is a tree and connects all the vertices together. A **Minimum Spanning Tree (MST)** is a spanning tree with the lowest possible total edge weight.

**Key Properties of an MST:**

- For a graph with `V` vertices, its MST will always have `V - 1` edges. This property is crucial for the algorithm's termination condition.

[![PMST](G:\DSA\Slides\PMST\s1.png)

---
## How Prim's Algorithm Works

Prim's algorithm builds the MST **edge by edge**, starting from an arbitrary vertex and progressively adding the cheapest edge that connects a vertex already in the MST to a vertex not yet in the MST.

The general steps are as follows:

1. **Initialization**:
    
    - Start by selecting an **arbitrary vertex** to be the first vertex in the solution (i.e., added to the MST). In the provided C++ implementation, the first vertex (index 0) is initially selected (`selected = true`).
    - Keep track of the number of selected edges, initialized to zero (`selected_edges_count{0}`).
    - Maintain a boolean array (e.g., `selected`) to mark which vertices are already part of the MST.
2. **Iteration**:
    
    - The algorithm continues looping **while the `selected_edges_count` is less than `V - 1`** (where `V` is the total number of vertices). This ensures that exactly `V - 1` edges are chosen, forming a spanning tree.
    - In each iteration, the goal is to find the **minimum weight edge** that connects a vertex already in the growing MST to a vertex not yet in the MST.
        - Initialize a variable `min` to a very large value (e.g., `INT_MAX`) to store the minimum edge weight found in the current iteration.
        - Initialize `temp_from` and `temp_to` to `-1` to store the indices of the vertices connected by this minimum edge.
        - **Iterate through all vertices `i`**:
            - **If vertex `i` is already in the `selected` set (i.e., `selected[i] == true`)**:
                - **Iterate through all vertices `j`**:
                    - **If vertex `j` is NOT in the `selected` set (`selected[j] == false`) AND there is an edge between `i` and `j` (`graph[i][j] != 0`) AND the weight of this edge (`graph[i][j]`) is less than the current `min` value**:
                        - Update `min` with `graph[i][j]`.
                        - Store `i` in `temp_from` and `j` in `temp_to`.
3. **Adding to MST**:
    
    - Once the inner loops complete, `temp_to` will hold the index of the vertex that is connected by the minimum weight edge to the current MST. This vertex is then added to the MST by setting `selected[temp_to] = true`.
    - Increment `selected_edges_count` by one.
    - The selected edge (from `labels[temp_from]` to `labels[temp_to]`) and its weight (`graph[temp_from][temp_to]`) are then printed.

[![PMST](G:\DSA\Slides\PMST\s20.png)

---
## C++ Implementation Details

The provided C++ implementation [[7.2.2-Prim’s Minimum Spanning Tree – Code#Complete Code Implementation]] uses:

- Standard I/O (`iostream`).
- `vector` for dynamic arrays (though a fixed-size C-style array is used for `graph` and `selected` in `main`).
- `climits` for `INT_MAX` to initialize the `min` variable.
- A 2D `double` array `graph` represents the **adjacency matrix** of the graph, where `graph[i][j]` stores the weight of the edge between vertex `i` and vertex `j`. A value of `0` indicates no direct edge or the edge to itself.
- A `char` array `labels[]` is used to represent the names of the vertices (e.g., '1', '2', '3', '4', '5', '6').
- A `bool` array `selected` keeps track of which vertices have been included in the MST.

**Example Graph from Source Code:** The example `graph` matrix represents a graph with 6 vertices:

```c++
{0, 6.7, 5.2, 2.8, 5.6, 3.6},
{6.7, 0, 5.7, 7.3, 5.1, 3.2},
{5.2, 5.7, 0, 3.4, 8.5, 4.0},
{2.8, 7.3, 3.4, 0, 8, 4.4},
{5.6, 5.1, 8.5, 8, 0, 4.6},
{3.6, 3.2, 4, 4.4, 4.6, 0}
```

This graph is depicted visually in the sources (Fig. 5 (a) in), and its "shortest spanning subtree" (MST) is also shown (Fig. 5 (b)) with a total length `L = 17.6`. The solution summary for this specific graph lists the selected edges and their lengths:

- 1 - 4 : 2.8
- 4 - 3 : 3.4
- 1 - 6 : 3.6
- 6 - 2 : 3.2
- 6 - 5 : 4.6

[![PMST](G:\DSA\Slides\PMST\s2.png)

[![PMST](G:\DSA\Slides\PMST\s21.png)

---
## Visual Progression of Prim's Algorithm

The sources illustrate the step-by-step execution of Prim's algorithm on a larger graph with nodes A-I. The process highlights nodes and edges as they are added to the MST (yellow for selected nodes/edges, red for edges not chosen). The final MST formed connects all nodes using the minimum total weight edges.

[![PMST](G:\DSA\Slides\PMST\s5.png)

[![PMST](G:\DSA\Slides\PMST\s6.png)

[![PMST](G:\DSA\Slides\PMST\s7.png)

[![PMST](G:\DSA\Slides\PMST\s8.png)

[![PMST](G:\DSA\Slides\PMST\s8.png)

[![PMST](G:\DSA\Slides\PMST\s9.png)

[![PMST](G:\DSA\Slides\PMST\s10.png)

[![PMST](G:\DSA\Slides\PMST\s11.png)

[![PMST](G:\DSA\Slides\PMST\s12.png)

[![PMST](G:\DSA\Slides\PMST\s12.png)

[![PMST](G:\DSA\Slides\PMST\s13.png)

[![PMST](G:\DSA\Slides\PMST\s14.png)

[![PMST](G:\DSA\Slides\PMST\s15.png)

[![PMST](G:\DSA\Slides\PMST\s16.png)

[![PMST](G:\DSA\Slides\PMST\s17.png)

[![PMST](G:\DSA\Slides\PMST\s18.png)

[![PMST](G:\DSA\Slides\PMST\s19.png)

---
## Historical Context

#### Prim's Minimum Spanning Tree algorithm was described by **R. C. Prim** in his 1957 manuscript "Shortest Connection Networks And Some Generalizations". Other notable algorithms for finding MSTs include Kruskal's algorithm and Borůvka's algorithm.

[![PMST](G:\DSA\Slides\PMST\s4.png)

---

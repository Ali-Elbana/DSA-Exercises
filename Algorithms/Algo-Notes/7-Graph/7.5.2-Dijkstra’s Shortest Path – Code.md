## Overview

This implementation demonstrates Dijkstra's shortest path algorithm using a graph representation with vertices and edges. The code finds the shortest path from vertex A to all other vertices in a weighted, directed graph.

## Code Structure

### Class Hierarchy

```
Graph
├── Contains vector<Vertex*> vertices
│
Vertex
├── string name
├── vector<Edge> edges
├── bool isVisited
├── double totalDist
├── Vertex* prev
│
Edge
├── Vertex* target
├── double weight
```

## Class Definitions

### Edge Class

```cpp
class Edge {
    Vertex* target;  // Pointer to destination vertex
    double weight;   // Weight of the edge
}
```

- **Purpose**: Represents a weighted connection between vertices
- **Key Features**: Simple structure holding target vertex and edge weight

### Vertex Class

```cpp
class Vertex {
    string name;                    // Vertex identifier
    vector<Edge> edges;            // Outgoing edges
    bool isVisited;                // Tracking flag (unused in current implementation)
    double totalDist;              // Distance from source
    Vertex* prev;                  // Previous vertex in shortest path
}
```

- **Purpose**: Represents a graph node with adjacency list
- **Key Features**:
    - Stores shortest distance from source
    - Maintains parent pointer for path reconstruction
    - Uses infinity as initial distance

### Graph Class

```cpp
class Graph {
    vector<Vertex*> vertices;      // Collection of all vertices
}
```

- **Purpose**: Container for the entire graph structure
- **Key Methods**:
    - `addEdges()`: Builds graph structure
    - `Dijkstra()`: Core algorithm implementation
    - `printPath()`: Recursive path display
    - `reset()`: Reinitializes vertex states

## Algorithm Implementation

### Dijkstra Method Analysis

```cpp
void Dijkstra(void) {
    vertices[0]->totalDist = 0;  // Set source distance to 0
    
    for(auto & v : vertices) {
        for(const auto & edge : v->edges) {
            double newDist = v->totalDist + edge.weight;
            
            if(newDist < edge.target->totalDist) {
                edge.target->totalDist = newDist;
                edge.target->prev = v;
            }
        }
    }
}
```

**Algorithm Steps**:

1. Initialize source vertex (A) distance to 0
2. For each vertex in the graph:
    - Examine all outgoing edges
    - Calculate new distance through current vertex
    - Update target vertex if shorter path found
    - Set parent pointer for path reconstruction

## Graph Structure

The implementation creates a 10-vertex graph (A through J) with the following connections:

```
A → B(2), C(4), D(3)
B → E(7), F(4), G(6)
C → E(3), F(2), G(4)
D → E(4), F(1), G(5)
E → H(1), I(4)
F → H(6), I(3)
G → H(3), I(3)
H → J(3)
I → J(4)
```

## Key Features

### Path Reconstruction

- Uses `prev` pointers to trace back from destination
- Recursive `printPath()` method builds path from source to target
- Automatically finds path to last vertex in the collection (vertex J)

### Memory Management

- Dynamic allocation of vertices using `new`
- Proper cleanup in destructor using `delete`
- RAII principle partially applied

### Reset Functionality

- `reset()` method reinitializes all vertex states
- Allows multiple algorithm runs on same graph instance

## Critical Analysis

### ⚠️ Implementation Issues

1. **Not True Dijkstra's**: Missing priority queue for optimal vertex selection
2. **Incorrect Algorithm**: Uses simple edge relaxation without proper ordering
3. **Suboptimal Results**: May not find truly shortest paths in all cases
4. **Fixed Path**: Only finds path to last vertex, not flexible destination

### ✅ Positive Aspects

- Clean class design with clear separation of concerns
- Good memory management practices
- Functional path reconstruction
- Readable code structure

## Time Complexity

- **Current Implementation**: O(V × E) where V = vertices, E = edges
- **True Dijkstra's**: O((V + E) log V) with binary heap
- **Space Complexity**: O(V + E) for graph storage

## Potential Improvements

1. Add priority queue for proper vertex selection
2. Implement flexible source/destination selection
3. Add input validation and error handling
4. Consider using smart pointers for memory safety
5. Add support for negative weight detection

## Usage Example

```cpp
vector<string> vertexNames = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J"};
Graph g(vertexNames);
// Add edges...
g.Dijkstra();  // Finds shortest path from A to J
```

## Tags

#algorithms #dijkstra #shortest-path 

## Complete Code Implementation

```cpp
#include <iostream>
#include <vector>
#include <stdexcept> 
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>
#include <iomanip>
#include <limits>

using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::queue;
using std::priority_queue;
using std::unordered_map;
using std::numeric_limits;

// Forward declaration
class Vertex;

class Edge {
public:
    Vertex * target;
    double weight;
    
    Edge() {}
    Edge(Vertex * t, double w): target(t), weight(w) {}
};

class Vertex {
public:
    string name;
    vector<Edge> edges;
    bool isVisited{false};
    double totalDist = numeric_limits<double>::infinity();
    Vertex * prev{nullptr};
    
    Vertex() {}
    Vertex(string n) : name(n) {}	
};

class Graph {
private:
    vector<Vertex *> vertices;

public:
    // Constructor - create graph with node names
    Graph(const vector<string> & names) {
        for(const auto & name : names) {
            vertices.push_back(new Vertex(name));
        }
    }
    
    // Add all node edges
    void addEdges(int from, const vector<int> & to, const vector<double> & weights) {
        for(size_t i = 0; i < to.size(); ++i) {
            vertices[from]->edges.emplace_back(vertices[to[i]], weights[i]);
        }
    }
    
    void Dijkstra(void) {
        vertices[0]->totalDist = 0;
        
        for(auto & v : vertices) {
            for(const auto & edge : v->edges) {
                double newDist = v->totalDist + edge.weight;
                
                if(newDist < edge.target->totalDist) {
                    edge.target->totalDist = newDist;
                    edge.target->prev = v;
                }
            }
        }
        
        cout << endl;
        printPath(vertices.back()); // Start from last element
        reset();
    }
    
    void printPath(Vertex * v) {
        if(v->prev != nullptr) {
            printPath(v->prev);
        }
        
        cout << v->name;
        
        if(v != vertices.back()) {
            cout << " --> ";
        } else {
            cout << endl;
        }
    }
    
    void reset() {
        for(auto & v : vertices) {
            v->isVisited = false;
            v->totalDist = numeric_limits<double>::infinity();
            v->prev = nullptr;
        }
    }
    
    // Destructor
    ~Graph() {
        for(auto v : vertices) {
            delete v;
        }
    }
};

int main() {
    system("cls");
    
    vector<string> vertexNames = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J"};
    Graph g(vertexNames);
    
    // Add edges
    g.addEdges(0, {1, 2, 3}, {2, 4, 3});        // A -> B(2), C(4), D(3)
    g.addEdges(1, {4, 5, 6}, {7, 4, 6});        // B -> E(7), F(4), G(6)
    g.addEdges(2, {4, 5, 6}, {3, 2, 4});        // C -> E(3), F(2), G(4)
    g.addEdges(3, {4, 5, 6}, {4, 1, 5});        // D -> E(4), F(1), G(5)
    g.addEdges(4, {7, 8}, {1, 4});              // E -> H(1), I(4)
    g.addEdges(5, {7, 8}, {6, 3});              // F -> H(6), I(3)
    g.addEdges(6, {7, 8}, {3, 3});              // G -> H(3), I(3)
    g.addEdges(7, {9}, {3});                    // H -> J(3)
    g.addEdges(8, {9}, {4});                    // I -> J(4)
    
    // Run algorithm
    g.Dijkstra();  // Find shortest paths from A
    cout << endl;

    return 0;
}
```
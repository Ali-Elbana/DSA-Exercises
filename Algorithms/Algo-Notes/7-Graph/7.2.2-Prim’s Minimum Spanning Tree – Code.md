# Prim's Minimum Spanning Tree Algorithm

## Overview

**Algorithm**: Prim's MST (Greedy Algorithm)  
**Time Complexity**: O(V²) with adjacency matrix, O((V + E) log V) with priority queue  
**Space Complexity**: O(V²) for adjacency matrix + O(V) for tracking  
**Tags**: #algorithms #graph-theory #minimum-spanning-tree #greedy #prims

## Problem Statement

Given a connected, undirected, weighted graph, find a subset of edges that connects all vertices with the minimum total edge weight. This subset forms a **Minimum Spanning Tree (MST)**.

## Algorithm Explanation

### Core Principle

Prim's algorithm is a **greedy algorithm** that builds the MST by:

1. Starting with an arbitrary vertex
2. Repeatedly adding the **minimum weight edge** that connects a vertex in the MST to a vertex outside the MST
3. Continuing until all vertices are included

### Key Properties

- **Cut Property**: The minimum weight edge crossing any cut is safe for the MST
- **Cycle Property**: The maximum weight edge in any cycle can be safely removed
- **Result**: Always produces an optimal MST for connected graphs

## Complete Code Implementation

```cpp
/*
*
* Problem description:
* Implement the Prim's Minimum Spanning Tree algorithm.
*
*/
#include <iostream>
#include <vector>
#include <stdexcept> 
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>
#include <iomanip>
#include <climits>

using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::priority_queue;
using std::unordered_map;

/************************* Declarations **************************/
/****************************************************************/

/*********************** Application ***************************/
/**************************************************************/

int main() 
{
    
    system("cls");
	
	char labels[] = {'1', '2', '3', '4', '5', '6'};
	double graph[6][6] = 
	{
      {0, 6.7, 5.2, 2.8, 5.6, 3.6}, {6.7, 0, 5.7, 7.3, 5.1, 3.2},
      {5.2, 5.7, 0, 3.4, 8.5, 4.0}, {2.8, 7.3, 3.4, 0, 8, 4.4},
      {5.6, 5.1, 8.5, 8, 0, 4.6},   {3.6, 3.2, 4, 4.4, 4.6, 0}
	};
	int v = 6;
	int selected_edges_count{0};
	bool selected[6] = {false};
	selected[0] = true;
	
	while(selected_edges_count < v - 1)
	{
		double min = INT_MAX;
		int temp_from{-1};
		int temp_to{-1};
		
		for(int i = 0; i < v; ++i)
		{
			if(selected[i] == true) // Check that the node is already selected to move to another node.
			{
				for(int j = 0; j < v; ++j)
				{
					if(selected[j] == false && graph[i][j] != 0 && graph[i][j] < min)
					{
						min = graph[i][j];
						temp_from = i;
						temp_to = j;
					}
				}
			}
		}
		
		selected[temp_to] = true;
		selected_edges_count++;
		
		// print the selected edge
		cout << ' ' << labels[temp_from] << " - " << labels[temp_to] << " : "
			 << graph[temp_from][temp_to] << endl;
			
		
	}
	
    return 0;
}

/********************* Function definitions *********************/
/****************************************************************/
/****************************************************************/
/****************************************************************/
```

## Implementation Details

### Graph Representation

- **Adjacency Matrix**: 6×6 matrix with edge weights
- **Vertices**: Labeled as '1', '2', '3', '4', '5', '6'
- **Edge Weights**: Double precision floating-point values
- **Self-loops**: Diagonal elements are 0 (no self-loops)

### Test Graph Structure

```
    1 ---- 2
   /|\    /|\
  / | \  / | \
 /  |  \/  |  \
6   |  /\  |   3
|   | /  \ |   |
|   |/    \|   |
5 --+------4---+
```

**Edge Weights**:

- 1-2: 6.7, 1-3: 5.2, 1-4: 2.8, 1-5: 5.6, 1-6: 3.6
- 2-3: 5.7, 2-4: 7.3, 2-5: 5.1, 2-6: 3.2
- 3-4: 3.4, 3-5: 8.5, 3-6: 4.0
- 4-5: 8.0, 4-6: 4.4, 5-6: 4.6

## Algorithm Walkthrough

### Step-by-Step Execution

1. **Initialize**: Start with vertex 1 (index 0)
2. **Iteration 1**: Find minimum edge from {1} → Select 1-4 (2.8)
3. **Iteration 2**: Find minimum edge from {1,4} → Select 4-3 (3.4)
4. **Iteration 3**: Find minimum edge from {1,4,3} → Select 2-6 (3.2)
5. **Iteration 4**: Find minimum edge from {1,4,3,6} → Select 6-3 (4.0)
6. **Iteration 5**: Find minimum edge from {1,4,3,6,2} → Select 6-5 (4.6)

### Expected Output

```
1 - 4 : 2.8
4 - 3 : 3.4
2 - 6 : 3.2
3 - 6 : 4.0
6 - 5 : 4.6
```

**Total MST Weight**: 2.8 + 3.4 + 3.2 + 4.0 + 4.6 = 18.0

## Code Analysis

### Data Structures

|Structure|Purpose|Size|
|---|---|---|
|`graph[6][6]`|Adjacency matrix|O(V²)|
|`selected[6]`|Track included vertices|O(V)|
|`labels[]`|Vertex labels for output|O(V)|

### Algorithm Flow

1. **Initialization**: Mark starting vertex as selected
2. **Main Loop**: Repeat until V-1 edges are selected
3. **Edge Selection**: Find minimum weight edge crossing the cut
4. **Update**: Add new vertex to MST, increment edge count
5. **Output**: Display selected edge and weight

## Key Observations

### Strengths

- ✅ Correct implementation of Prim's algorithm
- ✅ Clear variable naming and structure
- ✅ Handles weighted graphs with floating-point precision
- ✅ Simple and readable nested loop approach

### Areas for Improvement

- **Data Type Mismatch**: Uses `INT_MAX` for `double` comparison
- **Magic Numbers**: Hard-coded array size (6) throughout code
- **No Input Validation**: Assumes well-formed graph structure
- **Memory Usage**: O(V²) space even for sparse graphs
- **Performance**: O(V²) time complexity for all cases

### Potential Optimizations

```cpp
// Better initialization for floating-point comparison
double min = std::numeric_limits<double>::max();

// Use constants for graph size
const int VERTICES = 6;

// Priority queue implementation for O((V+E)logV) complexity
priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;
```

## Complexity Analysis

|Aspect|This Implementation|Optimized (Priority Queue)|
|---|---|---|
|Time|O(V²)|O((V + E) log V)|
|Space|O(V²)|O(V + E)|
|Best For|Dense graphs|Sparse graphs|

## Comparison with Other MST Algorithms

|Algorithm|Time Complexity|Space|Best Use Case|
|---|---|---|---|
|**Prim's**|O(V²) or O(E log V)|O(V²) or O(V)|Dense graphs|
|**Kruskal's**|O(E log E)|O(V + E)|Sparse graphs|
|**Borůvka's**|O(E log V)|O(V + E)|Parallel processing|

## Applications

- **Network Design**: Minimum cost to connect all nodes
- **Circuit Design**: Minimizing wire length in PCBs
- **Transportation**: Optimal road/railway network planning
- **Clustering**: Building dendrograms in data analysis

## Practice Problems

- LeetCode 1584: Min Cost to Connect All Points
- LeetCode 1135: Connecting Cities With Minimum Cost
- HackerRank: Prim's (MST): Special Subtree
- CodeChef: Minimum Spanning Tree

## Variations

- **Dense Graph Prim's**: O(V²) with adjacency matrix
- **Sparse Graph Prim's**: O((V + E) log V) with priority queue
- **Fibonacci Heap Prim's**: O(E + V log V) theoretical optimum

---

# Breadth-First Search (BFS) Algorithm

## Overview

**Algorithm**: Breadth-First Search (Graph Traversal)  
**Time Complexity**: O(V + E) where V = vertices, E = edges  
**Space Complexity**: O(V) for queue and visited array  
**Tags**: #algorithms #graph-theory #traversal #breadth-first-search #queue

## Problem Statement

Given a graph represented as an adjacency list, implement the Breadth-First Search algorithm to traverse all reachable nodes level by level, starting from a given source node. BFS explores all neighbors at the current depth before moving to nodes at the next depth level.

## Algorithm Explanation

### Core Principle

BFS uses a **queue (FIFO)** data structure to ensure nodes are visited in breadth-first order:

1. **Start** with source node, mark as visited
2. **Enqueue** source node
3. **While queue not empty**:
    - Dequeue a node
    - For each unvisited neighbor:
        - Mark as visited
        - Enqueue neighbor
        - Process/print the edge

### Key Properties

- **Level-order traversal**: Visits all nodes at distance k before visiting nodes at distance k+1
- **Shortest path**: In unweighted graphs, BFS finds shortest paths from source
- **Connected components**: Can detect if graph is connected

## Complete Code Implementation

```cpp
/*
*
* Problem description:
* Implement the Breadth First Search algorithm.
*
*/
#include <iostream>
#include <vector>
#include <stdexcept> 
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>
#include <iomanip>
#include <climits>

using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::vector;
using std::pair;
using std::queue;
using std::priority_queue;
using std::unordered_map;

/************************* Declarations **************************/
/****************************************************************/

class Graph
{
	private:
	vector<string> nodeNames;
	vector<vector<int>> adjacencyList;
	
	public:
	// Constructor - create graph with node names
	Graph(vector<string> & nNames)
	{
		nodeNames = nNames;
		adjacencyList.resize(nodeNames.size());
	}
	
	// Add edges for a node
	void addEdges(int nodeIdx, vector<int> connections)
	{
		adjacencyList[nodeIdx] = connections;
	}
	
	// Simple BFS implementation
    void BFS() 
	{
        cout << "\n BFS Traversal:\n";
		
		int numNodes = nodeNames.size();
		
		vector<bool> isVisited(numNodes, false);
		
		queue<int> trackConnectionsQue;
		
		trackConnectionsQue.push(0);; // 0 --> "A"
		isVisited[0] = true;
		
		while(trackConnectionsQue.empty() == false)
		{
			
			int currentNode = trackConnectionsQue.front();
			trackConnectionsQue.pop();
			
			for(int connection : adjacencyList[currentNode])
			{
				if(isVisited[connection] == false)
				{
					trackConnectionsQue.push(connection);
					isVisited[connection] = true;
					
					// Print all the edge being traversed
                    cout << ' ' << nodeNames[currentNode] << " - " << nodeNames[connection] << endl;
				}
			}
		}
		
	}
};

/*********************** Application ***************************/
/**************************************************************/

int main() 
{
    
    system("cls");
	
	// Create graph with same nodes as original
    vector<string> names{"A", "B", "C", "D", "E", "F", "G", "H", "I"};
	
	Graph g(names);
	
	// Add same edges as original
    g.addEdges(0, {1, 2});        // A connects to B, C
    g.addEdges(1, {0, 3, 4});     // B connects to A, D, E
    g.addEdges(2, {0, 3, 5});     // C connects to A, D, F
    g.addEdges(3, {1, 2, 4});     // D connects to B, C, E
    g.addEdges(4, {1, 5});        // E connects to B, F
    g.addEdges(5, {2, 3, 4, 7});  // F connects to C, D, E, H
    g.addEdges(6, {7, 8});        // G connects to H, I
    g.addEdges(7, {5, 6, 8});     // H connects to F, G, I
    g.addEdges(8, {6, 7});        // I connects to G, H
	
	g.BFS();
	
    return 0;
}

/********************* Function definitions *********************/
/****************************************************************/
/****************************************************************/
/****************************************************************/
```

## Implementation Details

### Graph Structure

The graph consists of **9 nodes** labeled A through I, represented as:

```
Indices: 0, 1, 2, 3, 4, 5, 6, 7, 8
Labels:  A, B, C, D, E, F, G, H, I
```

### Graph Visualization

```
    A ---- B ---- D ---- E
    |      |      |      |
    |      |      |      |
    C ---- F ---- H      |
    |      |      |      |
    |      |      |      |
    D      G ---- I      F
```

**Adjacency List Representation**:

- **A(0)**: [B(1), C(2)]
- **B(1)**: [A(0), D(3), E(4)]
- **C(2)**: [A(0), D(3), F(5)]
- **D(3)**: [B(1), C(2), E(4)]
- **E(4)**: [B(1), F(5)]
- **F(5)**: [C(2), D(3), E(4), H(7)]
- **G(6)**: [H(7), I(8)]
- **H(7)**: [F(5), G(6), I(8)]
- **I(8)**: [G(6), H(7)]

## Algorithm Walkthrough

### Step-by-Step Execution (Starting from A)

| Step | Queue State | Current Node | Visited                     | Action                   |
| ---- | ----------- | ------------ | --------------------------- | ------------------------ |
| 1    | [A]         | -            | [A]                         | Initialize with A        |
| 2    | [B, C]      | A            | [A]                         | Process A, add B, C      |
| 3    | [C, D, E]   | B            | [A, B]                      | Process B, add D, E      |
| 4    | [D, E, F]   | C            | [A, B, C]                   | Process C, add F         |
| 5    | [E, F]      | D            | [A, B, C, D]                | Process D (no new nodes) |
| 6    | [F]         | E            | [A, B, C, D, E]             | Process E (no new nodes) |
| 7    | [H]         | F            | [A, B, C, D, E, F]          | Process F, add H         |
| 8    | [G, I]      | H            | [A, B, C, D, E, F, H]       | Process H, add G, I      |
| 9    | [I]         | G            | [A, B, C, D, E, F, H, G]    | Process G (no new nodes) |
| 10   | []          | I            | [A, B, C, D, E, F, H, G, I] | Process I (no new nodes) |

### Expected Output

```
BFS Traversal:
 A - B
 A - C
 B - D
 B - E
 C - F
 F - H
 H - G
 H - I
```

## Code Structure Analysis

### Class Components

|Component|Type|Purpose|
|---|---|---|
|`nodeNames`|`vector<string>`|Store vertex labels|
|`adjacencyList`|`vector<vector<int>>`|Store graph connections|
|`Graph(vector<string>&)`|Constructor|Initialize graph with node names|
|`addEdges(int, vector<int>)`|Method|Add edges for a specific node|
|`BFS()`|Method|Perform breadth-first traversal|

### BFS Algorithm Components

|Variable|Type|Purpose|
|---|---|---|
|`isVisited`|`vector<bool>`|Track visited nodes|
|`trackConnectionsQue`|`queue<int>`|FIFO queue for BFS|
|`currentNode`|`int`|Current node being processed|
|`connection`|`int`|Neighbor node being examined|

## Key Observations

### Strengths

- ✅ **Correct BFS Implementation**: Uses queue for proper level-order traversal
- ✅ **Clear Data Structure**: Simple adjacency list representation
- ✅ **Good Variable Naming**: Descriptive names like `trackConnectionsQue`, `isVisited`
- ✅ **Proper Visited Tracking**: Prevents infinite loops and duplicate visits
- ✅ **Edge Output**: Shows traversal path for debugging/visualization

### Areas for Improvement

- **Code Style**: Double semicolon `trackConnectionsQue.push(0);;`
- **Condition Check**: `trackConnectionsQue.empty() == false` could be `!trackConnectionsQue.empty()`
- **Platform Dependency**: `system("cls")` is Windows-specific
- **Missing Features**: No disconnected component handling
- **Input Validation**: No bounds checking for node indices

### Potential Enhancements

```cpp
// Handle disconnected components
void BFS_AllComponents() {
    vector<bool> visited(numNodes, false);
    for (int i = 0; i < numNodes; i++) {
        if (!visited[i]) {
            BFS_FromNode(i, visited);
        }
    }
}

// Parameterized starting node
void BFS_FromNode(int startNode, vector<bool>& visited) {
    // BFS implementation starting from startNode
}
```

## Complexity Analysis

|Aspect|Complexity|Explanation|
|---|---|---|
|**Time**|O(V + E)|Visit each vertex once + examine each edge once|
|**Space**|O(V)|Queue + visited array|
|**Queue Operations**|O(V)|Each vertex enqueued/dequeued exactly once|
|**Adjacency List Traversal**|O(E)|Each edge examined exactly once|

## Comparison with DFS

|Feature|BFS|DFS|
|---|---|---|
|**Data Structure**|Queue (FIFO)|Stack (LIFO)|
|**Traversal Order**|Level-by-level|Depth-first|
|**Shortest Path**|✅ Finds shortest path|❌ May not find shortest|
|**Memory Usage**|O(V) worst case|O(h) where h = height|
|**Applications**|Shortest path, level-order|Topological sort, cycle detection|

## Applications

- **Shortest Path**: Finding shortest path in unweighted graphs
- **Level-Order Traversal**: Tree/graph level-by-level processing
- **Connected Components**: Finding all connected components
- **Bipartite Graph Check**: Determining if graph is bipartite
- **Social Networks**: Finding degrees of separation
- **Web Crawling**: Systematic webpage discovery
- **GPS Navigation**: Finding shortest routes (with modifications)

## Practice Problems

- LeetCode 102: Binary Tree Level Order Traversal
- LeetCode 107: Binary Tree Level Order Traversal II
- LeetCode 111: Minimum Depth of Binary Tree
- LeetCode 127: Word Ladder
- LeetCode 200: Number of Islands
- LeetCode 994: Rotting Oranges

## Variations

- **Multi-source BFS**: Starting from multiple nodes simultaneously
- **Bidirectional BFS**: Search from both source and target
- **0-1 BFS**: BFS variant for graphs with 0/1 edge weights
- **BFS on Grid**: 2D matrix traversal using BFS

---

# Array Operations - Resize & GetAt Methods

## Project Information

- **Project**: Make Resize & GetAt methods for arrays
- **File**: ArrOps.cpp
- **Author**: Ali El-bana
- **Date**: 2025-08-10
- **Version**: v1.0
- **Purpose**: Educational - Understanding custom array operations

## Overview

This project implements custom array operations through a `OurArray` class that provides:

- **Resize**: Dynamically resize arrays while preserving existing data
- **GetAt**: Safe element access with bounds checking

## Class Structure

### OurArray Class

The main class containing template methods for array manipulation:

#### Methods:

1. **`Resize<T>(T*& sourcePtr, int oldSize, int newSize)`**
    
    - Dynamically resizes an array from `oldSize` to `newSize`
    - Preserves existing data when possible
    - Handles memory management automatically
    - Uses `std::copy` for efficient data transfer
2. **`GetAt<T>(T* ArrPtr, int size, int idx)`**
    
    - Safe element access with bounds checking
    - Returns element at specified index
    - Returns default value `T()` for invalid access

## Key Features

### Memory Management

- Proper allocation and deallocation using `new[]` and `delete[]`
- Prevents memory leaks by cleaning up old arrays
- Initialize new elements with default values

### Safety Features

- **Bounds checking** in GetAt method
- **Null pointer validation** in both methods
- **Size validation** to prevent invalid operations

### Template Design

- Generic implementation works with any data type
- Type-safe operations
- Compile-time type checking

## Code Flow Example

```
Initial array: [1, 2, 3] (size 3)
↓ Resize to size 5
New array: [1, 2, 3, 0, 0] (size 5)
↓ GetAt(index 2)
Returns: 3
```

## Usage Patterns

1. Create array pointer with initial data
2. Instantiate OurArray object
3. Call Resize to change array size
4. Use GetAt for safe element access

## Learning Objectives

- Understanding dynamic memory allocation
- Template method implementation
- Safe array operations
- Memory management best practices
- Pointer manipulation and reference parameters

## Notes

- Educational implementation - not for production use
- Demonstrates fundamental C++ concepts
- Focus on understanding memory management
- Template methods provide type flexibility

---

## Complete Code

```cpp
/*
============================================================
* Project: [Make Resize & GetAt methods for arrays]
* File:    [ArrOps.cpp]
* Author:  [Ali El-bana]
* Date:    [2025-08-10]
* Version: [v1.0]
------------------------------------------------------------
* Description:
* [Create Resize and GetAt methods for arrays with yourself to 
 understand more what's happened]
------------------------------------------------------------
* Notes:
* [This is for educational purpose]
============================================================
*/
/* ====================== Includes ====================== */
#include <iostream>
#include <algorithm>
/* =================== Namespace Usage ================== */
using std::cout;
using std::cin;
using std::endl;
/* =================== Global Constants ================= */
// const double PI = 3.14159;
/* ====================== Declarations ================== */
// ▼▼▼ Class: OurArray ▼▼▼
class OurArray;
// ▲▲▲ End of OurArray ▲▲▲
/* ===================== Class Definitions =============== */
// ▼▼▼ Class: OurArray ▼▼▼
class OurArray 
{
    // members & methods
	public:
	// ▼▼▼ Method: Resize ▼▼▼
	template<typename T>
	void Resize(T *& sourcePtr, int oldSize, int newSize)
	{
		// Validations:
		if(newSize < 1 || sourcePtr == nullptr || newSize == oldSize)
		{
			return;
		}
		else
		{
			// Create new array
			T * newArr = new T[newSize]{}; // Initialize all elements with default typedef
			
			// Copy elements from the old array to the new one
			std::copy(sourcePtr, sourcePtr + std::min(oldSize, newSize), newArr);
			
			// Delete the old chunks that sourcePtr points to
			delete[] sourcePtr;
			
			// Assign the new array to the sourcePtr
			sourcePtr = newArr;
		}
	}
	// ▲▲▲ End of Resize ▲▲▲
	
	// ▼▼▼ Method: GetAt ▼▼▼
	template<typename T>
	T GetAt(T * ArrPtr, int size, int idx)
	{
		T result{-1};
		
		// Validations:
		if(idx < 0 || idx >= size || ArrPtr == nullptr)
		{
			return T();
		}
		else
		{
			result = *(ArrPtr + idx);
		}
		
		return result;
	}
	// ▲▲▲ End of GetAt ▲▲▲
	
};
// ▲▲▲ End of OurArray ▲▲▲
/* ==================== Function Prototypes ============== */
// ▼▼▼ Function: exampleFunction ▼▼▼
// void exampleFunction(int param);
// ▲▲▲ End of exampleFunction ▲▲▲
/* ==================== Main Application ================= */
int main(void) 
{
    // ----- Initialization -----
    system("cls");
    cout << "Program started...\n";
	int * arr = new int[3]{1,2,3};
	OurArray newArr;
	
    // ----- Logic -----
    // [Your code here]
	newArr.Resize(arr, 3, 5);
	
	cout << "\nThe array after resizing: ";
	for(int i = 0; i < 5; i++) 
	{
		cout << arr[i] << " ";
    }
	
	int item = newArr.GetAt(arr, 5, 2);
	
	cout << "\nItem = " << item << '\n';
	
    // ----- End -----
    return 0;
}
/* ================== Function/Method Definitions =============== */
// ▼▼▼ exampleFunction Definition ▼▼▼
// ▲▲▲ End of exampleFunction ▲▲▲
/* ======================= End of File =================== */
```
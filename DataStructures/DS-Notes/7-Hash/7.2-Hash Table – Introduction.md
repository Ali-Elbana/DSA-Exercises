
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=68cf172e-f3f0-45ba-b80b-70b6bdc119ae)

---
## Hash Table Overview

A Hash Table is fundamentally a **collection of Key-Value pairs**. All keys within a Hash Table must be of the same type, and similarly, all values must be of the same type.

[![HashTable](G:\DSA\Slides\HashTable-Intro\s1.png)

---
### Core Operations

The fundamental operations that define a HashTable are:

- **Converting Key to array index**.
- **Collision handling**.

[![HashTable](G:\DSA\Slides\HashTable-Intro\s15.png)

---
### The `Set` Function

The `Set` function in a HashTable, which can be thought of as a dictionary operation, involves the following steps:

1. **Search for the Key**: The process begins by searching for the given key. This search can be performed in **O(1) time**.
2. **Key Exists**: If the key is found, the associated value is **updated**.
3. **Key Does Not Exist**: If the key is not found:
    - A `ResizeOrNot()` function is called.
    - A **new KeyValuePair is created** and added to the HashTable's entries.
    - The `entriesCount` is then incremented.

[![HashTable](G:\DSA\Slides\HashTable-Intro\s2.png)

[![HashTable](G:\DSA\Slides\HashTable-Intro\s3.png)

---
### Converting Key to Array Index

Keys are converted into array indices to determine where in the internal array the KeyValuePairs will be stored. This conversion typically involves:

1. Applying a **hash function** (e.g., FNV hash) to the key to produce a numerical hash value.
2. Taking the **modulo of the hash value** by the data length (or array size, `n`) to get the final array index (e.g., `key % data length` or `Hash % n`).

[![HashTable](G:\DSA\Slides\HashTable-Intro\s4.png)

[![HashTable](G:\DSA\Slides\HashTable-Intro\s5.png)

---
### Collision Handling

Collision handling is a crucial aspect of HashTables, addressing scenarios where different keys hash to the same array index. "Probing" generally refers to searching or inquiring closely into something. The sources describe two main categories of collision handling: **Open Addressing** (also known as closed hashing) and **Closed Addressing** (also known as open hashing).

[![HashTable](G:\DSA\Slides\HashTable-Intro\s9.png)

[![HashTable](G:\DSA\Slides\HashTable-Intro\s14.png)

---
#### Open Addressing (Closed Hashing)

In Open Addressing, if a collision occurs, the system attempts to find an alternative location within the _same_ hash table array. The methods listed are:

- **Linear Probing**: If the initial hash index (`hash`) is occupied, subsequent locations are checked linearly using the formula `(hash + i) % n`, where `i` increments from 1. "Linear" in mathematics describes a direct proportional change or something represented by a straight line.
    - _Example_: If "Arist" hashes to 2, and index 2 is occupied, it checks `(2 + 1) % 5 = 3`, then `(2 + 2) % 5 = 4`, and so on.
- **Quadratic Probing**: If the initial hash index is occupied, locations are checked by adding the square of `i` to the hash, using the formula `(hash + i^2) % n`. "Quadratic" refers to a value multiplied by itself (i.e., squared).
    - _Example_: If "Arist" hashes to 2, and index 2 is occupied, it checks `(2 + (1 * 1)) % 5 = 4`, then `(2 + (2 * 2)) % 5 = 1`.
- **Double Hashing**: This method uses a second hash function to determine the step size for probing. The formula for the new hash is `(hash + hash2) % n`, where `hash2` is often calculated as `(hash + i) % n`.
    - _Example_: If "Arist" hashes to 2, and index 2 is occupied, it checks `(2 + (2 + 1) % 5) % 5 = 0`, then `(2 + (2 + 2) % 5) % 5 = 1`.

[![HashTable](G:\DSA\Slides\HashTable-Intro\s10.png)

[![HashTable](G:\DSA\Slides\HashTable-Intro\s11.png)

[![HashTable](G:\DSA\Slides\HashTable-Intro\s12.png)

---
#### Closed Addressing (Open Hashing)

In Closed Addressing, if a collision occurs, the entry is placed in another data structure (like a linked list) that is associated with the calculated hash index, rather than finding a new index within the main array.

- **Separate Chaining**: If multiple keys hash to the same index, they are stored in a linked list (or similar data structure) at that particular index. This method allows for the use of any other data structure in conjunction with the current hash table.
    - _Example_: If "Arist" hashes to 2, and index 2 is occupied by "Sinar", "Arist" would be added to a chain (e.g., a linked list) starting from index 2.

[![HashTable](G:\DSA\Slides\HashTable-Intro\s13.png)

---

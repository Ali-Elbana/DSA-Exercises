
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=1a4cc56f-b325-46f2-8677-ac1701704bea)

---
## Hashing and FNV-1a Algorithm

### What is a Hash?

A **hash** is a fixed-length value composed of randomly arranged letters and numbers. It can be represented in formats like decimal or hexadecimal.

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s1.png)

---
### What is a Hash Function?

A **hash function** is a mechanism that generates a hash from data of any size. Common hash functions include MD5, SHA1, FNV-1a, NTLM, SHA2, and SHA256. Conceptually, a simple hash function might operate like `hash = data % n`. A **Hash Table** is where a map between the original data and its hash is stored, with "map" in mathematics meaning a one-to-one relationship.

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s2.png)

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s3.png)

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s5.png)

---
### The FNV-1a Hash Algorithm

The **Fowlerâ€“Nollâ€“Vo (FNV-1a)** hash algorithm is designed to support both 32-bit and 64-bit variants for string input.

**Core Algorithm Steps:**

1. **Initialization:** The hash is initialized with an `offset_basis` value.
2. **Iteration:** For each `octet_of_data` (character in a string) to be hashed:
    - The current hash is **XORed** with the `octet_of_data` (`hash = hash xor octet_of_data`).
    - The hash is then **multiplied** by an `FNV_Prime` value (`hash = hash * FNV_Prime`).
3. **Result:** The final hash value is returned.

**Key Constants:** The algorithm uses specific `offset_basis` and `prime` values for its 32-bit and 64-bit variants:

- **32-bit FNV-1a:**
    - **Offset Basis:** `2166136261U`
    - **Prime:** `16777619U`
- **64-bit FNV-1a:**
    - **Offset Basis:** `14695981039346656037ULL`
    - **Prime:** `1099511628211ULL`

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s6.png)

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s7.png)

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s8.png)

---
**Implementation Details (C++ Example):** An example C++ implementation includes a `Hash` class with `Hash32` and `Hash64` methods. These methods process input strings character by character, applying the XOR and multiplication steps as described. The implementation also provides formatted output in both decimal and hexadecimal representations.

For instance, hashing the string **"This is Original Text"** using FNV-1a yields specific results:

- **32-bit Hash:** `d60b93a5`

It's important to note that the FNV-1a algorithm is **case-sensitive**. Slight changes in casing result in significantly different hash values:

- "This is Original Text" -> `d60b93a5`
- "this is original text" -> `9b8d5b05`
- "this is original TEXT" -> `98e0be45`

**The code reference:** [[7.1.2-Hashing â€“ Introduction â€“ FNV-1a - Code#ðŸ’¾ Complete Code Implementation]]

---
### XOR Logical Operator

The **XOR (Exclusive OR)** logical operator is a crucial part of the FNV-1a algorithm. Its truth table is as follows:

- 0 XOR 0 = 0
- 1 XOR 0 = 1
- 0 XOR 1 = 1
- 1 XOR 1 = 0 This means XOR returns true (1) if and only if its inputs differ. An example of 'A' XOR 'z' demonstrating binary operation is provided in the sources.



---
### Hash Collisions

A **hash collision** occurs when two different inputs produce the exact same hash output. For example, the strings 'mdsAnalysisResult105588' and 'mdsAlertCompleteResult360224' both result in the hash `2535747266`.

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s13.png)

---
### Common Usage of Hashing

Hashing functions have various practical applications:

- Saving passwords in databases
- Database indexing
- Domain Name Servers (DNSSEC)
- File Fingerprints (for integrity checks)
- And more

[![FVN1a](G:\DSA\Slides\Hashing-FNV\s14.png)

---


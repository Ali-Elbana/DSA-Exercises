**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=aa4eb9a2-c5e7-4df3-8a87-db6e1956bed2)

---

**C++ Hash Table Implementation Overview**

This Hash Table implementation utilizes an array as its underlying **infrastructure** and provides core **operations** such as `set`, `get`, `remove`, `resize`, and `size`.

[![HashTable](G:\DSA\Slides\HashTable-Implement\s1.png)

- **Internal Structure:**
    
    - The hash table stores data in a `vector<pair<string, string>>` named `entries`. Each pair represents a key-value entry.
    - It tracks `initialSize` (which changes during resizing, initially 3) and `entriesCount` (the number of actual entries stored).

**The code reference:** [[7.3.2-Hash Table â€“ Implementation - Code#Complete Code Implementation]]

- **Hashing Mechanism (`GetHash`)**:
    
    - The hash function used is **FNV-1a**.
    - It takes a `string key` as input.
    - The process begins with an `FnvOffsetBasis` (2166136261).
    - For each character (octet) in the key, the current hash value is first **XORed** with the character, then **multiplied** by an `FNVPrime` (16777619).
    - The final hash index is calculated by taking the result modulo the `initialSize` (or `hashtable_length`).

[![HashTable](G:\DSA\Slides\HashTable-Implement\s2.png)

- **Collision Handling (`CollisionHandling`)**:
    
    - When a collision occurs (i.e., the calculated hash index is already occupied by a _different_ key), the implementation uses **Linear Probing**.
    - It probes for an alternative index by adding `i` (starting from 1 and incrementing) to the original hash and taking the result modulo `initialSize`: `newHash = (hash + i) % this->initialSize`.
    - For `set` operations, it searches for an empty spot or an existing entry with the same key.
    - For `get` or `remove` operations, it searches specifically for an existing entry with the matching key.
    - If no suitable index is found after probing through the entire table (excluding the original hash position), it returns -1.

[![HashTable](G:\DSA\Slides\HashTable-Implement\s3.png)

- **Adding/Setting Entries (`Set`, `AddToEntries`)**:
    
    - The `Set` function orchestrates the process: it first calls `ResizeOrNot()` and then `AddToEntries()`.
    - `AddToEntries` calculates the initial hash.
    - If the calculated hash index is occupied by a different key, it invokes `CollisionHandling` to find an appropriate slot.
    - If a slot is found:
        - If the slot is empty, a new key-value pair is inserted, and `entriesCount` is incremented.
        - If the slot already contains the same key, its value is updated.
    - The implementation throws `runtime_error` for invalid states, such as when no valid index can be found for a new key.

[![HashTable](G:\DSA\Slides\HashTable-Implement\s6.png)

[![HashTable](G:\DSA\Slides\HashTable-Implement\s4.png)

- **Retrieving Entries (`Get`)**:
    
    - The `Get` function first calculates the hash for the given key.
    - If the entry at the initial hash index does not match the key, it calls `CollisionHandling` to find the correct entry.
    - It returns the associated value if the key is found, or an empty string (`""`) if not found (e.g., if `CollisionHandling` returns -1). It might also throw a `runtime_error` if the table is in an "invalid" state.

[![HashTable](G:\DSA\Slides\HashTable-Implement\s9.png)

- **Resizing (`ResizeOrNot`)**:
    
    - The table resizes when `entriesCount` becomes equal to `initialSize`. This means the table is full.
    - The `ResizeOrNot` function doubles the `initialSize`.
    - It creates a copy of the existing entries, clears the original `entries` vector, and then resizes it to the `newSize`.
    - Crucially, it then **rehashes** all existing entries from the copy by calling `AddToEntries` for each non-empty entry. This re-populates the new, larger table with correctly calculated indices.
    - This design resolves a potential **circular dependency** where `ResizeOrNot` might have directly called `Set`, which in turn calls `ResizeOrNot`; instead, both `Set` and `ResizeOrNot` call the more fundamental `AddToEntries` function.

[![HashTable](G:\DSA\Slides\HashTable-Implement\s5.png)

[![HashTable](G:\DSA\Slides\HashTable-Implement\s7.png)

[![HashTable](G:\DSA\Slides\HashTable-Implement\s8.png)

- **Removing Entries (`Remove`)**:
    
    - The `Remove` function calculates the hash for the key.
    - If the entry at the initial hash index does not match the key, it calls `CollisionHandling` to locate the correct entry.
    - If the key is found, the entry's `first` and `second` elements are cleared (set to empty strings), and `entriesCount` is decremented.
    - A significant part of the `Remove` operation involves **re-hashing displaced entries**. After an entry is removed, subsequent entries that might have been placed in their current position due to the removed entry (or other entries before it) are identified. These displaced entries are then cleared from their current positions and re-added to the table using `AddToEntries`, ensuring correct placement and preserving the integrity of linear probing chains.
    - If the key is not found, it prints a message and returns `false`.
- **Utility Functions (`Size`, `Count`, `Print`)**:
    
    - `Size()` returns the total capacity of the hash table (the size of the `entries` vector).
    - `Count()` returns the number of active key-value pairs (`entriesCount`).
    - `Print()` provides a formatted output of the table's current size, count, and the content of each index, marking empty slots as "null".

---
## Overview

A custom hash table implementation using **linear probing** for collision resolution and **FNV-1a hashing algorithm**. The implementation features dynamic resizing, comprehensive debugging output, and standard hash table operations.

## Key Features

- **FNV-1a Hash Function**: Fast, non-cryptographic hash with good distribution
- **Linear Probing**: Simple collision resolution strategy
- **Dynamic Resizing**: Automatically doubles size when load factor reaches 100%
- **Debug Logging**: Extensive console output for learning and troubleshooting
- **Standard Operations**: Set, Get, Remove with proper error handling

## Architecture

### Core Components

- **Storage**: `vector<pair<string, string>>` for key-value pairs
- **Size Management**: Tracks both total capacity and occupied entries
- **Collision Handling**: Linear probing with wraparound

### Class Structure

```cpp
class HashTable {
private:
    vector<pair<string, string>> entries;
    int initialSize;    // Current capacity
    int entriesCount;   // Number of occupied slots

public:
    // Constructor, destructor, and methods
};
```

## Hash Function Details

### FNV-1a Algorithm

```
hash = FNV_offset_basis
for each byte in data:
    hash = hash XOR byte
    hash = hash * FNV_prime
return hash % table_size
```

**Constants Used:**

- `FnvOffsetBasis = 2166136261`
- `FNVPrime = 16777619`

**Advantages:**

- Fast computation
- Good distribution properties
- Low collision rates for typical string data

## Collision Resolution

### Linear Probing Strategy

When a collision occurs at index `i`:

1. Try `(i + 1) % table_size`
2. Try `(i + 2) % table_size`
3. Continue until empty slot found or full cycle completed

### Implementation Details

- **Set Operations**: Find first empty slot or existing key
- **Get/Remove Operations**: Search until key found or empty slot encountered
- **Wraparound**: Uses modulo arithmetic for circular probing

## Dynamic Resizing

### Resize Trigger

- Occurs when `entriesCount >= initialSize` (100% load factor)
- New size = `old_size * 2`

### Resize Process

1. Create temporary copy of current entries
2. Clear and resize main storage
3. Reset entry counter
4. Rehash all non-empty entries from copy
5. Update capacity variable

## Operations Complexity

|Operation|Average Case|Worst Case|
|---|---|---|
|Get|O(1)|O(n)|
|Set|O(1)*|O(n)*|
|Remove|O(1)|O(n)|

*Amortized due to resizing

## Key Methods

### `GetHash(string key)`

- Computes FNV-1a hash
- Returns index within current table bounds
- Includes debug output

### `Set(string key, string value)`

- Triggers resize check first
- Handles both new insertions and updates
- Uses collision resolution if needed

### `Get(string key)`

- Returns value for given key
- Returns empty string if key not found
- Throws exception on internal errors

### `Remove(string key)`

- Removes key-value pair
- Handles rehashing of displaced entries
- Returns boolean success status
- **Note**: Current implementation has complex rehashing logic that may have edge cases

## Debug Output

The implementation provides extensive logging:

- `[hash]`: Hash calculation details
- `[coll]`: Collision resolution steps
- `[resize]`: Resize operations
- `[remove]`: Removal operations
- Table state printing with `Print()` method

## Usage Example

```cpp
HashTable table;

// Adding entries
table.Set("name", "John");
table.Set("email", "john@example.com");

// Retrieving values
string email = table.Get("email");

// Removing entries
bool removed = table.Remove("name");

// Checking table state
table.Print();
```

## Limitations and Considerations

### Current Issues

1. **Remove Method**: Complex rehashing logic may have edge cases
2. **Load Factor**: Always resizes at 100% load, which is quite high
3. **Memory Usage**: No shrinking when entries are removed
4. **Error Handling**: Mix of exceptions and return codes

### Potential Improvements

- Implement proper tombstone markers for deletions
- Add shrinking capability for better memory usage
- Lower resize threshold (e.g., 75% load factor)
- Consistent error handling strategy
- Template-based implementation for generic key-value types

## Learning Value

This implementation is excellent for understanding:

- Hash table fundamentals
- Collision resolution strategies
- Dynamic resizing mechanics
- FNV hashing algorithm
- Linear probing behavior

The extensive debug output makes it particularly valuable for educational purposes, allowing you to observe the internal mechanics of hash table operations.

---

## Complete Code Implementation

```cpp
#include <cstring>
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>
#include <iomanip>
#include <cstdint>

using namespace std;

class HashTable {
private:
public:
  vector<pair<string, string>> entries;
  int initialSize;
  int entriesCount;

public:
  HashTable() {
    this->initialSize = 3;
    this->entriesCount = 0;
    this->entries = vector<pair<string, string>>(this->initialSize);
  }

  ~HashTable() { this->entries.clear(); }

  int GetHash(string key) {
    uint32_t FnvOffsetBasis = 2166136261;
    uint32_t FNVPrime = 16777619;

    string keyStr = key;
    const char *data = keyStr.c_str();
    uint32_t hash = FnvOffsetBasis;

    for (size_t i = 0; i < strlen(data); i++) {
      hash = hash ^ data[i];
      hash = hash * FNVPrime;
    }

    cout << "[hash] " << keyStr << " " << hash << " " << hex << hash << " "
         << hash % static_cast<uint32_t>(this->initialSize) << endl;

    return hash % static_cast<uint32_t>(this->initialSize);
  }

  int CollisionHandling(string key, int hash, bool set) {
    int newHash;
    for (int i = 1; i < this->initialSize; i++) {
      newHash = (hash + i) % this->initialSize;

      cout << "[coll] " << key << " " << hash << ", new hash: " << newHash
           << endl;

      if (set && ((this->entries[newHash].first == "" &&
                   this->entries[newHash].second == "") ||
                  this->entries[newHash].first == key)) {
        return newHash;
      } else if (!set && this->entries[newHash].first == key) {
        return newHash;
      }
    }
    return -1;
  }

  void AddToEntries(string key, string value) {
    int hash = this->GetHash(key);
    if (hash == -1) {
      throw runtime_error("Invalid Hashtable!!!!");
    }

    if (this->entries[hash].first != "" && this->entries[hash].second != "" &&
        this->entries[hash].first != key) {
      hash = this->CollisionHandling(key, hash, true);
    }

    if (hash < this->entries.size() && this->entries[hash].second != value &&
        entries[hash].first != key) {
      this->entries[hash] = pair<string, string>({key, value});
      this->entriesCount++;
    } else if (this->entries[hash].first == key) {
      this->entries[hash].second = value;
    } else {
      throw runtime_error("Invalid Hashtable!!!!");
    }
  }

  void ResizeOrNot() {
    if (this->entriesCount < this->initialSize) {
      return;
    }
    int newSize = this->initialSize * 2;

    cout << "[resize] from " << this->initialSize << " to " << newSize << endl;

    vector<pair<string, string>> entriesCopy(this->initialSize);
    entriesCopy = this->entries;
    this->entries.clear();
    this->entries.resize(newSize);
    this->entriesCount = 0;

    for (int i = 0; i < this->initialSize; i++) {
      if (entriesCopy[i].first == "" && entriesCopy[i].second == "")
        continue;
      this->AddToEntries(entriesCopy[i].first, entriesCopy[i].second);
    }

    this->initialSize = newSize;
    entriesCopy.clear();
  }

  void Set(string key, string value) {
    this->ResizeOrNot();
    this->AddToEntries(key, value);
  }

  string Get(string key) {
    int hash = GetHash(key);
    if (hash < (int)(this->entries.size()) && entries[hash].first != key) {
      hash = CollisionHandling(key, hash, false);
    }
    if (hash == -1 || hash >= this->entries.size()) {
      return "";
    }

    if (entries[hash].first == key) {
      return entries[hash].second;
    } else {
      throw runtime_error("Invalid Hashtable!!!!");
    }
  }

  bool Remove(string key) {
    int hash = GetHash(key);
    if (hash < (int)(this->entries.size()) && entries[hash].first != key) {
      hash = CollisionHandling(key, hash, false);
    }
    
    if (hash == -1 || hash >= this->entries.size()) {
      cout << "[remove] Key '" << key << "' not found" << endl;
      return false;
    }

    if (entries[hash].first == key) {
      cout << "[remove] Removing key '" << key << "' from index " << hash << endl;
      
      // Mark the entry as deleted
      entries[hash].first = "";
      entries[hash].second = "";
      this->entriesCount--;
      
      // Need to rehash entries that might have been displaced by this entry
      // Find all entries that come after this position and were displaced
      vector<pair<string, string>> toRehash;
      int nextIndex = (hash + 1) % this->initialSize;
      
      while (nextIndex != hash && 
             (entries[nextIndex].first != "" || entries[nextIndex].second != "")) {
        
        if (entries[nextIndex].first != "") {
          // Check if this entry's natural hash position is before or at the removed position
          int naturalHash = GetHash(entries[nextIndex].first);
          
          // If the natural position is affected by the removal, we need to rehash
          if ((naturalHash <= hash && nextIndex > hash) || 
              (naturalHash > nextIndex && (naturalHash <= hash || nextIndex > hash))) {
            toRehash.push_back(entries[nextIndex]);
            entries[nextIndex].first = "";
            entries[nextIndex].second = "";
            this->entriesCount--;
          }
        }
        
        nextIndex = (nextIndex + 1) % this->initialSize;
      }
      
      // Rehash the displaced entries
      for (const auto& entry : toRehash) {
        this->AddToEntries(entry.first, entry.second);
      }
      
      return true;
    } else {
      cout << "[remove] Key '" << key << "' not found" << endl;
      return false;
    }
  }

  int Size() { return this->entries.size(); }
  
  int Count() { return this->entriesCount; }
  
  void Print() {
    std::cout << "-----------" << std::endl;
    std::cout << "[Size] " << Size() << " [Count] " << Count() << std::endl;

    for (int i = 0; i < Size(); i++) {
      if (entries[i].second == "") {
        std::cout << "[" << i << "] null" << std::endl;
      } else {
        std::cout << "[" << i << "] " << entries[i].first << ":"
                  << entries[i].second << std::endl;
      }
    }

    std::cout << "============" << std::endl;
  }
};

int main() {
  HashTable table;
  table.Print();
  
  table.Set("Sinar", "sinar@gmail.com");
  table.Set("Elvis", "elvis@gmail.com");
  table.Set("Tane", "tane@gmail.com");
  table.Print();
  
  cout << "[get] " << table.Get("Sinar") << endl;
  cout << "[get] " << table.Get("Tane") << endl;
  
  table.Set("Gerti", "gerti@gmail.com");
  table.Set("Arist", "arist@gmail.com");
  table.Print();
  
  cout << "[get] " << table.Get("Sinar") << endl;
  
  // Test Remove functionality
  cout << "\n--- Testing Remove ---" << endl;
  table.Remove("Elvis");
  table.Print();
  
  cout << "[get] Elvis after removal: '" << table.Get("Elvis") << "'" << endl;
  cout << "[get] Sinar after Elvis removal: " << table.Get("Sinar") << endl;
  
  // Try to remove non-existent key
  table.Remove("NonExistent");
  
  return 0;
}
```

## Tags

#cpp #datastructures #hashtable #algorithms #programming #fnv-hash #linear-probing
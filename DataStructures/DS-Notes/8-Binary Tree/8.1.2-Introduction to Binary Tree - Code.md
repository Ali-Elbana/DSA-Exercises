## üìã Project Overview

**Author:** Ali El-bana  
**Date:** 2025-08-20  
**Version:** v1.0  
**Language:** C++

A template-based binary tree implementation featuring level-order insertion and visual tree representation in console output.

## üéØ Key Features

- **Template-based design** - Supports any comparable data type
- **Level-order insertion** - Uses breadth-first strategy for balanced insertion
- **Visual tree printing** - ASCII art representation in console
- **Memory management** - Proper destructor with recursive cleanup
- **Cross-platform** - Compatible with Windows/Linux/Mac

## üèóÔ∏è Architecture

### Class Structure

```
BinaryTree<Tdata>
‚îú‚îÄ‚îÄ TreeNode<Tdata>
‚îÇ   ‚îú‚îÄ‚îÄ Data (Tdata)
‚îÇ   ‚îú‚îÄ‚îÄ Left (TreeNode*)
‚îÇ   ‚îî‚îÄ‚îÄ Right (TreeNode*)
‚îî‚îÄ‚îÄ Methods
    ‚îú‚îÄ‚îÄ Public: Insert(), Print()
    ‚îî‚îÄ‚îÄ Private: destroyTree(), getHeight(), printTree()
```

### Core Components

1. **TreeNode Class**
    
    - Simple node structure with data and left/right pointers
    - Template-based for type flexibility
2. **BinaryTree Class**
    
    - Root pointer management
    - Level-order insertion algorithm
    - Visual tree printing functionality

## üîß Implementation Details

### Insertion Strategy

- Uses **level-order (breadth-first) insertion**
- Ensures balanced tree structure
- Utilizes queue data structure for traversal

### Tree Visualization

- ASCII-based tree representation
- Shows parent-child relationships clearly
- Handles empty trees gracefully

### Memory Management

- RAII principles with proper destructor
- Recursive memory cleanup
- No memory leaks

## üöÄ Usage Example

```cpp
// Create a character-based binary tree
BinaryTree<char> tree_char;

// Insert elements (level-order insertion)
tree_char.Insert('A');
tree_char.Insert('B');
tree_char.Insert('C');
tree_char.Insert('D');
tree_char.Insert('E');

// Display the tree structure
tree_char.Print();
```

**Expected Output:**

```
==================================================
         BINARY TREE VISUALIZATION
==================================================

|____ A
    |---- B
    |   |---- D
    |   |____ E
    |____ C
```

## üí° Algorithm Analysis

### Time Complexity

- **Insertion:** O(n) - worst case, must traverse to find insertion point
- **Destruction:** O(n) - visits each node once
- **Height calculation:** O(n) - recursive traversal
- **Printing:** O(n) - visits each node once

### Space Complexity

- **Storage:** O(n) - n nodes in the tree
- **Insertion:** O(w) - queue can hold at most width of tree
- **Recursion:** O(h) - stack depth equals tree height

## üîÑ Possible Enhancements

- [ ] Add search functionality
- [ ] Implement deletion operations
- [ ] Add tree traversal methods (inorder, preorder, postorder)
- [ ] Include tree balancing algorithms
- [ ] Add serialization/deserialization
- [ ] Implement iterator pattern
- [ ] Add tree comparison operations

## üêõ Known Limitations

- No balancing mechanism (can become skewed with certain input patterns)
- Level-order insertion may not preserve any specific ordering property
- No duplicate handling policy defined
- Limited to console-based visualization

---
## Complete Code Implementation

### BinaryTree.cpp

```cpp
/*
============================================================
* Project: Binary Tree Implementation
* File:    BinaryTree.cpp
* Author:  [Ali El-bana]
* Date:    [2025-08-20]
* Version: v1.0
------------------------------------------------------------
* Description:
* Template-based binary tree implementation with level-order
* insertion and visual tree printing functionality
------------------------------------------------------------
* Notes:
* - Uses level-order (breadth-first) insertion strategy
* - Includes visual tree representation in console output
* - Template class supports any comparable data type
============================================================
*/

/* ====================== Includes ====================== */
#include <iostream>
#include <queue>
#include <vector>
#include <string>
#include <iomanip>
#include <cmath>

/* =================== Namespace Usage ================== */
using std::cout;
using std::endl;
using std::queue;
using std::vector;
using std::string;
using std::setw;
using std::setfill;

/* ====================== Declarations ================== */
// ‚ñº‚ñº‚ñº Class: TreeNode ‚ñº‚ñº‚ñº
template <typename Tdata>
class TreeNode;
// ‚ñ≤‚ñ≤‚ñ≤ End of TreeNode ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Class: BinaryTree ‚ñº‚ñº‚ñº
template <typename Tdata>
class BinaryTree;
// ‚ñ≤‚ñ≤‚ñ≤ End of BinaryTree ‚ñ≤‚ñ≤‚ñ≤

/* ===================== Class Definitions =============== */
// ‚ñº‚ñº‚ñº Class: TreeNode ‚ñº‚ñº‚ñº
template<typename Tdata>
class TreeNode
{
public:
	Tdata Data;
	TreeNode<Tdata> * Left;
	TreeNode<Tdata> * Right;
	
	// Constructor
	TreeNode(Tdata _data) : Data(_data), Left(nullptr), Right(nullptr) {}
};
// ‚ñ≤‚ñ≤‚ñ≤ End of TreeNode ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Class: BinaryTree ‚ñº‚ñº‚ñº
template<typename Tdata>
class BinaryTree
{
	
private:
	TreeNode<Tdata> * root;
	
	// ‚ñº‚ñº‚ñº Private Helper Methods ‚ñº‚ñº‚ñº
    void destroyTree(TreeNode<Tdata>* node);
    int getHeight(TreeNode<Tdata>* node);
    void printTree(TreeNode<Tdata>* node, string prefix, bool isLast);
    // ‚ñ≤‚ñ≤‚ñ≤ End of Private Helper Methods ‚ñ≤‚ñ≤‚ñ≤
	
public:
	
	// ‚ñº‚ñº‚ñº Constructor and Destructor ‚ñº‚ñº‚ñº
    BinaryTree();
    ~BinaryTree();
    // ‚ñ≤‚ñ≤‚ñ≤ End of Constructor and Destructor ‚ñ≤‚ñ≤‚ñ≤
    
    // ‚ñº‚ñº‚ñº Public Methods ‚ñº‚ñº‚ñº
    void Insert(Tdata _data);
    void Print();
    // ‚ñ≤‚ñ≤‚ñ≤ End of Public Methods ‚ñ≤‚ñ≤‚ñ≤

};
// ‚ñ≤‚ñ≤‚ñ≤ End of BinaryTree ‚ñ≤‚ñ≤‚ñ≤

/* ================== Method Definitions =============== */
// ‚ñº‚ñº‚ñº BinaryTree Constructor Definition ‚ñº‚ñº‚ñº
template<typename Tdata>
BinaryTree<Tdata>::BinaryTree()
{
	root = nullptr;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of BinaryTree Constructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº BinaryTree Destructor Definition ‚ñº‚ñº‚ñº
template<typename Tdata>
BinaryTree<Tdata>::~BinaryTree()
{
	destroyTree(root);
}
// ‚ñ≤‚ñ≤‚ñ≤ End of BinaryTree Destructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº destroyTree Definition ‚ñº‚ñº‚ñº
template <typename Tdata>
void BinaryTree<Tdata>::destroyTree(TreeNode<Tdata>* node) 
{
    if(node != nullptr) 
	{
        destroyTree(node->Left);
        destroyTree(node->Right);
        delete node;
    }
}
// ‚ñ≤‚ñ≤‚ñ≤ End of destroyTree ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Insert Definition ‚ñº‚ñº‚ñº
template <typename Tdata>
void BinaryTree<Tdata>::Insert(Tdata _data) 
{
	TreeNode<Tdata> * newNode = new TreeNode<Tdata>(_data);
	
	if(root == nullptr)
	{
		root = newNode;
		return;
	}
	else
	{
		
		queue<TreeNode<Tdata> *> q;
		q.push(root);
		
		while(q.empty() == false)
		{
			TreeNode<Tdata> * currNode = q.front();
			q.pop();
			
			if(currNode->Left == nullptr)
			{
				currNode->Left = newNode;
				break;
			}
			else
			{
				q.push(currNode->Left);
			}
			
			if(currNode->Right == nullptr)
			{
				currNode->Right = newNode;
				break;
			}
			else
			{
				q.push(currNode->Right);
			}
		}
	}
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Insert ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº getHeight Definition ‚ñº‚ñº‚ñº
template <typename Tdata>
int BinaryTree<Tdata>::getHeight(TreeNode<Tdata>* node) 
{
    if(node == nullptr) 
	{
        return 0;
    }
    
    int leftHeight = getHeight(node->Left);
    int rightHeight = getHeight(node->Right);
    
    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
}
// ‚ñ≤‚ñ≤‚ñ≤ End of getHeight ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº printTree Definition ‚ñº‚ñº‚ñº
template <typename Tdata>
void BinaryTree<Tdata>::printTree(TreeNode<Tdata>* node, string prefix, bool isLast) 
{
    if(node != nullptr) 
	{
        cout << prefix;
        cout << (isLast ? "|____ " : "|---- ");
        cout << node->Data << endl;
        
        // Count children to determine the connector
        bool hasLeft = (node->Left != nullptr);
        bool hasRight = (node->Right != nullptr);
        
        if(hasLeft || hasRight) 
		{
            if(hasLeft) 
			{
                printTree(node->Left, prefix + (isLast ? "    " : "|   "), !hasRight);
            }
            if(hasRight) 
			{
                printTree(node->Right, prefix + (isLast ? "    " : "|   "), true);
            }
        }
    }
}
// ‚ñ≤‚ñ≤‚ñ≤ End of printTree ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Print Definition ‚ñº‚ñº‚ñº
template <typename Tdata>
void BinaryTree<Tdata>::Print() 
{
    if (root == nullptr) {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\n" << string(50, '=') << endl;
    cout << "         BINARY TREE VISUALIZATION" << endl;
    cout << string(50, '=') << endl << endl;
    
    // Simple approach: print using the actual tree structure
    printTree(root, "", false);
    
    cout << endl << string(50, '=') << endl << endl;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Print ‚ñ≤‚ñ≤‚ñ≤

/* ======================= End of File =================== */
```

### main.cpp

```cpp
/*
============================================================
* Project: Binary Tree Implementation
* File:    main.cpp
* Author:  [Ali El-bana]
* Date:    [2025-08-20]
* Version: v1.0
------------------------------------------------------------
* Description:
* Main application to demonstrate binary tree functionality
* with visual tree representation
------------------------------------------------------------
* Notes:
* - Demonstrates insertion and printing of binary tree
* - Uses template-based implementation for flexibility
============================================================
*/

/* ====================== Includes ====================== */
#include "BinaryTree.cpp"
#include <iostream>

/* =================== Namespace Usage ================== */
using std::cout;
using std::endl;

/* ==================== Main Application ================= */
int main() 
{
    // ----- Initialization -----
    system("cls"); // Clear console (Windows)
    // system("clear"); // Uncomment for Linux/Mac
    cout << "Binary Tree Demonstration Program" << endl;
    cout << "=================================" << endl;
    
    // ----- Create and populate binary tree -----
    BinaryTree<char> tree_char;
    
    cout << "\nInserting elements: A, B, C, D, E, F, G, H, I" << endl;
    
    tree_char.Insert('A');
    tree_char.Insert('B');
    tree_char.Insert('C');
    tree_char.Insert('D');
    tree_char.Insert('E');
    tree_char.Insert('F');
    tree_char.Insert('G');
    tree_char.Insert('H');
    tree_char.Insert('I');
    
    // ----- Display the tree -----
    cout << "\nTree structure:" << endl;
    tree_char.Print();
    
    // ----- End -----
    cout << "Program completed successfully!" << endl;
    return 0;
}

/* ======================= End of File =================== */
```

## Compilation Instructions

```bash
# For Windows (MinGW/MSVC)
g++ -std=c++17 main.cpp -o binary_tree.exe

# For Linux/Mac
g++ -std=c++17 main.cpp -o binary_tree
./binary_tree
```

---


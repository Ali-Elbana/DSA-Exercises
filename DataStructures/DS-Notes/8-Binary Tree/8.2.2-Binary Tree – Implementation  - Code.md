## Overview

Template-based binary tree implementation in C++ with level-order insertion strategy and visual tree representation functionality.

## Key Features

- **Template-based design** - supports any comparable data type
- **Level-order insertion** - breadth-first insertion strategy for balanced filling
- **Visual tree representation** - ASCII art console output for tree structure
- **Complete traversal methods** - pre-order, in-order, and post-order traversals
- **Search functionality** - find elements in the tree
- **Node deletion** - remove nodes while maintaining tree structure
- **Memory management** - automatic cleanup with destructor

## Architecture

### Class Structure

The implementation consists of two main classes:

1. **TreeNode<Tdata\>** - Individual node structure
    
    - `Tdata Data` - stores the node value
    - `TreeNode<Tdata>* Left` - pointer to left child
    - `TreeNode<Tdata>* Right` - pointer to right child
2. **BinaryTree<Tdata\>** - Main tree management class
    
    - `TreeNode<Tdata>* root` - pointer to root node
    - Private helper methods for recursive operations
    - Public interface for tree operations

### Insertion Strategy

Uses **level-order (breadth-first) insertion**:

- Fills the tree level by level from left to right
- Ensures the tree remains as balanced as possible
- Uses a queue to track the next available position

## Public Methods

|Method|Description|
|---|---|
|`Insert(Tdata _data)`|Insert new element using level-order strategy|
|`Print()`|Display visual tree representation|
|`preOrder()`|Traverse tree in pre-order (Root → Left → Right)|
|`inOrder()`|Traverse tree in in-order (Left → Root → Right)|
|`postOrder()`|Traverse tree in post-order (Left → Right → Root)|
|`find(Tdata _data)`|Search for element and return boolean result|
|`deleteNode(Tdata _data)`|Remove node while maintaining tree structure|

## Tree Traversal Methods

### Pre-Order Traversal

**Pattern:** Root → Left → Right  
**Use case:** Tree copying, expression tree evaluation

### In-Order Traversal

**Pattern:** Left → Root → Right  
**Use case:** Getting sorted sequence (for BST), expression evaluation

### Post-Order Traversal

**Pattern:** Left → Right → Root  
**Use case:** Tree deletion, calculating directory sizes

## Deletion Algorithm

The implementation uses a sophisticated deletion strategy:

1. **Find the target node** using level-order traversal
2. **Find the deepest rightmost node** (last node in level-order)
3. **Replace target node's data** with deepest rightmost node's data
4. **Delete the deepest rightmost node** by updating its parent's pointer
5. This maintains the tree's level-order structure

## Visual Output Example

```
==================================================
         BINARY TREE VISUALIZATION
==================================================

|____ A
    |---- B
    |   |---- D
    |   |____ E
    |____ C
        |---- F
        |____ G
```

## Usage Example

```cpp
// Create tree instance
BinaryTree<char> tree;

// Insert elements
tree.Insert('A');
tree.Insert('B'); 
tree.Insert('C');

// Display tree
tree.Print();

// Traverse tree
tree.preOrder();   // Output: A B C
tree.inOrder();    // Output: B A C  
tree.postOrder();  // Output: B C A

// Search operations
tree.find('B');    // Found
tree.find('X');    // Not found

// Delete node
tree.deleteNode('B');
```

## Time Complexity

|Operation|Time Complexity|Space Complexity|
|---|---|---|
|Insert|O(n)|O(n)|
|Search|O(n)|O(h)|
|Delete|O(n)|O(n)|
|Traversal|O(n)|O(h)|

_where n = number of nodes, h = height of tree_

## Memory Management

- **Constructor** initializes root to nullptr
- **Destructor** calls `destroyTree()` for recursive cleanup
- **destroyTree()** performs post-order deletion to avoid memory leaks
- All dynamic memory is properly managed

## Limitations

- **Not a Binary Search Tree** - no ordering property maintained
- **O(n) search time** - must check all nodes in worst case
- **Level-order insertion only** - cannot insert at specific positions
- **No balancing** - tree shape depends on insertion order

## Complete Code Implementation

### TreeNode and BinaryTree Class (BinaryTree.cpp)

```cpp
/*
============================================================
* Project: Binary Tree Implementation
* File:    BinaryTree.cpp
* Author:  [Ali El-bana]
* Date:    [2025-08-20]
* Version: v1.0
------------------------------------------------------------
* Description:
* Template-based binary tree implementation with level-order
* insertion and visual tree printing functionality
------------------------------------------------------------
* Notes:
* - Uses level-order (breadth-first) insertion strategy
* - Includes visual tree representation in console output
* - Template class supports any comparable data type
============================================================
*/

/* ====================== Includes ====================== */
#include <iostream>
#include <queue>
#include <vector>
#include <string>
#include <iomanip>
#include <cmath>

/* =================== Namespace Usage ================== */
using std::cout;
using std::endl;
using std::queue;
using std::vector;
using std::string;
using std::setw;
using std::setfill;

/* ====================== Declarations ================== */
// ▼▼▼ Class: TreeNode ▼▼▼
template <typename Tdata>
class TreeNode;
// ▲▲▲ End of TreeNode ▲▲▲

// ▼▼▼ Class: BinaryTree ▼▼▼
template <typename Tdata>
class BinaryTree;
// ▲▲▲ End of BinaryTree ▲▲▲

/* ===================== Class Definitions =============== */
// ▼▼▼ Class: TreeNode ▼▼▼
template<typename Tdata>
class TreeNode
{
public:
	Tdata Data;
	TreeNode<Tdata> * Left;
	TreeNode<Tdata> * Right;
	
	// Constructor
	TreeNode(Tdata _data) : Data(_data), Left(nullptr), Right(nullptr) {}
};
// ▲▲▲ End of TreeNode ▲▲▲

// ▼▼▼ Class: BinaryTree ▼▼▼
template<typename Tdata>
class BinaryTree
{
	
private:
	TreeNode<Tdata> * root;
	
	// ▼▼▼ Private Helper Methods ▼▼▼
    void destroyTree(TreeNode<Tdata>* node);
    int getHeight(TreeNode<Tdata>* node);
    void printTree(TreeNode<Tdata>* node, string prefix, bool isLast);
	void preOrderHelper(TreeNode<Tdata>* node);
    void inOrderHelper(TreeNode<Tdata>* node);
    void postOrderHelper(TreeNode<Tdata>* node);
	bool findHelper(TreeNode<Tdata>* node, Tdata _data);
    TreeNode<Tdata>* findDeepestRightmost(TreeNode<Tdata>* node);
    void deleteNodeHelper(TreeNode<Tdata>*& root, Tdata _data);
    // ▲▲▲ End of Private Helper Methods ▲▲▲
	
public:
	
	// ▼▼▼ Constructor and Destructor ▼▼▼
    BinaryTree();
    ~BinaryTree();
    // ▲▲▲ End of Constructor and Destructor ▲▲▲
    
    // ▼▼▼ Public Methods ▼▼▼
    void Insert(Tdata _data);
    void Print();
	void preOrder();
    void inOrder();
    void postOrder();
	bool find(Tdata _data);
    void deleteNode(Tdata _data);
    // ▲▲▲ End of Public Methods ▲▲▲

};
// ▲▲▲ End of BinaryTree ▲▲▲

/* ================== Method Definitions =============== */
// ▼▼▼ BinaryTree Constructor Definition ▼▼▼
template<typename Tdata>
BinaryTree<Tdata>::BinaryTree()
{
	root = nullptr;
}
// ▲▲▲ End of BinaryTree Constructor ▲▲▲

// ▼▼▼ BinaryTree Destructor Definition ▼▼▼
template<typename Tdata>
BinaryTree<Tdata>::~BinaryTree()
{
	destroyTree(root);
}
// ▲▲▲ End of BinaryTree Destructor ▲▲▲

// ▼▼▼ destroyTree Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::destroyTree(TreeNode<Tdata>* node) 
{
    if(node != nullptr) 
	{
        destroyTree(node->Left);
        destroyTree(node->Right);
        delete node;
    }
}
// ▲▲▲ End of destroyTree ▲▲▲

// ▼▼▼ Insert Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::Insert(Tdata _data) 
{
	TreeNode<Tdata> * newNode = new TreeNode<Tdata>(_data);
	
	if(root == nullptr)
	{
		root = newNode;
		return;
	}
	else
	{
		
		queue<TreeNode<Tdata> *> q;
		q.push(root);
		
		while(q.empty() == false)
		{
			TreeNode<Tdata> * currNode = q.front();
			q.pop();
			
			if(currNode->Left == nullptr)
			{
				currNode->Left = newNode;
				break;
			}
			else
			{
				q.push(currNode->Left);
			}
			
			if(currNode->Right == nullptr)
			{
				currNode->Right = newNode;
				break;
			}
			else
			{
				q.push(currNode->Right);
			}
		}
	}
}
// ▲▲▲ End of Insert ▲▲▲

// ▼▼▼ getHeight Definition ▼▼▼
template <typename Tdata>
int BinaryTree<Tdata>::getHeight(TreeNode<Tdata>* node) 
{
    if(node == nullptr) 
	{
        return 0;
    }
    
    int leftHeight = getHeight(node->Left);
    int rightHeight = getHeight(node->Right);
    
    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
}
// ▲▲▲ End of getHeight ▲▲▲

// ▼▼▼ printTree Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::printTree(TreeNode<Tdata>* node, string prefix, bool isLast) 
{
    if(node != nullptr) 
	{
        cout << prefix;
        cout << (isLast ? "|____ " : "|---- ");
        cout << node->Data << endl;
        
        // Count children to determine the connector
        bool hasLeft = (node->Left != nullptr);
        bool hasRight = (node->Right != nullptr);
        
        if(hasLeft || hasRight) 
		{
            if(hasLeft) 
			{
                printTree(node->Left, prefix + (isLast ? "    " : "|   "), !hasRight);
            }
            if(hasRight) 
			{
                printTree(node->Right, prefix + (isLast ? "    " : "|   "), true);
            }
        }
    }
}
// ▲▲▲ End of printTree ▲▲▲

// ▼▼▼ Print Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::Print() 
{
    if (root == nullptr) {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\n" << string(50, '=') << endl;
    cout << "         BINARY TREE VISUALIZATION" << endl;
    cout << string(50, '=') << endl << endl;
    
    // Simple approach: print using the actual tree structure
    printTree(root, "", false);
    
    cout << endl << string(50, '=') << endl << endl;
}
// ▲▲▲ End of Print ▲▲▲

// ▼▼▼ preOrderHelper Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::preOrderHelper(TreeNode<Tdata>* node)
{
    if(node != nullptr)
    {
        cout << node->Data << " ";
        preOrderHelper(node->Left);
        preOrderHelper(node->Right);
    }
}
// ▲▲▲ End of preOrderHelper ▲▲▲

// ▼▼▼ preOrder Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::preOrder()
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\nPre-Order Traversal (Root -> Left -> Right): ";
    preOrderHelper(root);
    cout << endl;
}
// ▲▲▲ End of preOrder ▲▲▲

// ▼▼▼ inOrderHelper Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::inOrderHelper(TreeNode<Tdata>* node)
{
    if(node != nullptr)
    {
        inOrderHelper(node->Left);
        cout << node->Data << " ";
        inOrderHelper(node->Right);
    }
}
// ▲▲▲ End of inOrderHelper ▲▲▲

// ▼▼▼ inOrder Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::inOrder()
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\nIn-Order Traversal (Left -> Root -> Right): ";
    inOrderHelper(root);
    cout << endl;
}
// ▲▲▲ End of inOrder ▲▲▲

// ▼▼▼ postOrderHelper Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::postOrderHelper(TreeNode<Tdata>* node)
{
    if(node != nullptr)
    {
        postOrderHelper(node->Left);
        postOrderHelper(node->Right);
        cout << node->Data << " ";
    }
}
// ▲▲▲ End of postOrderHelper ▲▲▲

// ▼▼▼ postOrder Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::postOrder()
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\nPost-Order Traversal (Left -> Right -> Root): ";
    postOrderHelper(root);
    cout << endl;
}
// ▲▲▲ End of postOrder ▲▲▲

// ▼▼▼ findHelper Definition ▼▼▼
template <typename Tdata>
bool BinaryTree<Tdata>::findHelper(TreeNode<Tdata>* node, Tdata _data)
{
    if(node == nullptr)
    {
        return false;
    }
    
    if(node->Data == _data)
    {
        return true;
    }
    
    // Search in both left and right subtrees
    return findHelper(node->Left, _data) || findHelper(node->Right, _data);
}
// ▲▲▲ End of findHelper ▲▲▲

// ▼▼▼ find Definition ▼▼▼
template <typename Tdata>
bool BinaryTree<Tdata>::find(Tdata _data)
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return false;
    }
    
    bool found = findHelper(root, _data);
    
    if(found)
    {
        cout << "Element " << _data << " found in the tree." << endl;
    }
    else
    {
        cout << "Element " << _data << " not found in the tree." << endl;
    }
    
    return found;
}
// ▲▲▲ End of find ▲▲▲

// ▼▼▼ findDeepestRightmost Definition ▼▼▼
template <typename Tdata>
TreeNode<Tdata>* BinaryTree<Tdata>::findDeepestRightmost(TreeNode<Tdata>* node)
{
    if(node == nullptr)
    {
        return nullptr;
    }
    
    queue<TreeNode<Tdata>*> q;
    q.push(node);
    TreeNode<Tdata>* deepest = nullptr;
    
    // Level order traversal to find the deepest rightmost node
    while(!q.empty())
    {
        deepest = q.front();
        q.pop();
        
        if(deepest->Left != nullptr)
        {
            q.push(deepest->Left);
        }
        
        if(deepest->Right != nullptr)
        {
            q.push(deepest->Right);
        }
    }
    
    return deepest;
}
// ▲▲▲ End of findDeepestRightmost ▲▲▲

// ▼▼▼ deleteNodeHelper Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::deleteNodeHelper(TreeNode<Tdata>*& root, Tdata _data)
{
    if(root == nullptr)
    {
        return;
    }
    
    // If only one node exists and it's the target
    if(root->Left == nullptr && root->Right == nullptr)
    {
        if(root->Data == _data)
        {
            delete root;
            root = nullptr;
        }
        return;
    }
    
    // Find the node to delete using level order traversal
    queue<TreeNode<Tdata>*> q;
    q.push(root);
    TreeNode<Tdata>* nodeToDelete = nullptr;
    TreeNode<Tdata>* lastNode = nullptr;
    
    // Find the target node and keep track of all nodes (lastNode will be the deepest rightmost)
    while(!q.empty())
    {
        lastNode = q.front();
        q.pop();
        
        if(lastNode->Data == _data)
        {
            nodeToDelete = lastNode;
        }
        
        if(lastNode->Left != nullptr)
        {
            q.push(lastNode->Left);
        }
        
        if(lastNode->Right != nullptr)
        {
            q.push(lastNode->Right);
        }
    }
    
    if(nodeToDelete == nullptr)
    {
        return; // Node not found
    }
    
    // Replace the data of nodeToDelete with the deepest rightmost node's data
    nodeToDelete->Data = lastNode->Data;
    
    // Now we need to delete the lastNode (deepest rightmost)
    // Find parent of lastNode using another level order traversal
    queue<TreeNode<Tdata>*> q2;
    q2.push(root);
    
    while(!q2.empty())
    {
        TreeNode<Tdata>* current = q2.front();
        q2.pop();
        
        // Check if current node is parent of lastNode
        if(current->Left == lastNode)
        {
            current->Left = nullptr;
            delete lastNode;
            return;
        }
        
        if(current->Right == lastNode)
        {
            current->Right = nullptr;
            delete lastNode;
            return;
        }
        
        if(current->Left != nullptr)
        {
            q2.push(current->Left);
        }
        
        if(current->Right != nullptr)
        {
            q2.push(current->Right);
        }
    }
    
}
// ▲▲▲ End of deleteNodeHelper ▲▲▲

// ▼▼▼ deleteNode Definition ▼▼▼
template <typename Tdata>
void BinaryTree<Tdata>::deleteNode(Tdata _data)
{
    if(root == nullptr)
    {
        cout << "Tree is empty! Cannot delete element " << _data << endl;
        return;
    }
    
    // Check if element exists first
    if(!findHelper(root, _data))
    {
        cout << "Element " << _data << " not found in the tree. Cannot delete." << endl;
        return;
    }
    
    deleteNodeHelper(root, _data);
    cout << "Element " << _data << " deleted from the tree." << endl;
}
// ▲▲▲ End of deleteNode ▲▲▲

/* ======================= End of File =================== */
```

### Main Application (main.cpp)

```cpp
/*
============================================================
* Project: Binary Tree Implementation
* File:    main.cpp
* Author:  [Ali El-bana]
* Date:    [2025-08-20]
* Version: v1.0
------------------------------------------------------------
* Description:
* Main application to demonstrate binary tree functionality
* with visual tree representation
------------------------------------------------------------
* Notes:
* - Demonstrates insertion and printing of binary tree
* - Uses template-based implementation for flexibility
============================================================
*/

/* ====================== Includes ====================== */
#include "BinaryTree.cpp"
#include <iostream>

/* =================== Namespace Usage ================== */
using std::cout;
using std::endl;

/* ==================== Main Application ================= */
int main() 
{
    // ----- Initialization -----
    system("cls"); // Clear console (Windows)
    // system("clear"); // Uncomment for Linux/Mac
    cout << "Binary Tree Demonstration Program" << endl;
    cout << "=================================" << endl;
    
    // ----- Create and populate binary tree -----
    BinaryTree<char> tree_char;
    
    cout << "\nInserting elements: A, B, C, D, E, F, G, H, I" << endl;
    
    tree_char.Insert('A');
    tree_char.Insert('B');
    tree_char.Insert('C');
    tree_char.Insert('D');
    tree_char.Insert('E');
    tree_char.Insert('F');
    tree_char.Insert('G');
    tree_char.Insert('H');
    tree_char.Insert('I');
    
    // ----- Display the tree -----
    cout << "\nTree structure:" << endl;
    tree_char.Print();
	
	// ----- Traverse in different orders -----
    tree_char.preOrder();
	tree_char.inOrder();
	tree_char.postOrder();
	
	// ----- Find node in the tree -----
	tree_char.find('I');
	tree_char.find('J');
	
	// ----- Find node from the tree -----
	tree_char.deleteNode('D');
	tree_char.deleteNode('K');
	
	// ----- Display the tree after deletion -----
    cout << "\nTree structure:" << endl;
    tree_char.Print();
	
    // ----- End -----
    cout << "Program completed successfully!" << endl;
    return 0;
}

/* ======================= End of File =================== */
```

## Tags

#cpp #data-structures #binary-tree #algorithms #templates #tree-traversal #level-order #visual-representation
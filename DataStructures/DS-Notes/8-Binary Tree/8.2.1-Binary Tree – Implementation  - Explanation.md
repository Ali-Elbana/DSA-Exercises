
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=97e9f863-f328-4d3e-ace2-2eceeba16bdb)

---
This project outlines a **C++ template-based binary tree implementation** [[8.2.2-Binary Tree â€“ Implementation  - Code#Complete Code Implementation]] designed to support **any comparable data type**. Authored by Ali El-bana, it was last updated on 2025-08-20, version v1.0. The implementation includes functionalities for **level-order insertion** and a **visual tree printing functionality** in the console output.

The core of the implementation consists of two template classes: `TreeNode` and `BinaryTree`.

[![BinTree](G:\DSA\Slides\BinTree-Implement\s1.png)

---
### Class Structure

- **`TreeNode<Tdata>` Class**:
    
    - **Public Members**:
        - `Data`: Stores the node's data of type `Tdata`.
        - `Left`: A pointer to the left child `TreeNode<Tdata>`.
        - `Right`: A pointer to the right child `TreeNode<Tdata>`.
    - **Constructor**:
        - `TreeNode(Tdata _data)`: Initializes a new node with `_data` and sets both `Left` and `Right` pointers to `nullptr`.
- **`BinaryTree<Tdata>` Class**:
    
    - **Private Member**:
        - `root`: A pointer to the root `TreeNode<Tdata>` of the tree.
    - **Private Helper Methods**: These methods manage the tree's internal operations, often recursively:
        - `destroyTree(TreeNode<Tdata>* node)`: Recursively deallocates memory for nodes.
        - `getHeight(TreeNode<Tdata>* node)`: Calculates the height of a subtree.
        - `printTree(TreeNode<Tdata>* node, string prefix, bool isLast)`: Assists in the visual printing of the tree.
        - `preOrderHelper(TreeNode<Tdata>* node)`: Performs pre-order traversal.
        - `inOrderHelper(TreeNode<Tdata>* node)`: Performs in-order traversal.
        - `postOrderHelper(TreeNode<Tdata>* node)`: Performs post-order traversal.
        - `findHelper(TreeNode<Tdata>* node, Tdata _data)`: Searches for a specific data element.
        - `findDeepestRightmost(TreeNode<Tdata>* node)`: Identifies the deepest rightmost node, used in deletion.
        - `deleteNodeHelper(TreeNode<Tdata>*& root, Tdata _data)`: Handles the deletion logic for a node.
    - **Public Methods**: These are the primary interfaces for interacting with the binary tree:
        - **Constructor**: `BinaryTree()`: Initializes the `root` to `nullptr`.
        - **Destructor**: `~BinaryTree()`: Calls `destroyTree` to clean up all allocated nodes.
        - `Insert(Tdata _data)`: Inserts a new element into the tree.
        - `Print()`: Displays the tree structure visually.
        - `preOrder()`: Initiates a pre-order traversal.
        - `inOrder()`: Initiates an in-order traversal.
        - `postOrder()`: Initiates a post-order traversal.
        - `find(Tdata _data)`: Searches for an element in the tree.
        - `deleteNode(Tdata _data)`: Removes an element from the tree.

[![BinTree](G:\DSA\Slides\BinTree-Implement\s12.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s85.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s86.png)

---
### Key Functionalities

1. **Insertion (`Insert`)**:
    
    - Uses a **level-order (breadth-first) insertion strategy**.
    - If the tree is empty, the new node becomes the root.
    - Otherwise, it traverses the tree level by level using a queue, inserting the new node at the first available left or right child position.
2. **Tree Visualization (`Print`, `printTree`)**:
    
    - The `Print()` method prepares the console output with headers and then calls the recursive `printTree` helper.
    - `printTree` recursively displays nodes with prefixes like `|____` or `|----` to visually represent parent-child relationships.
3. **Traversal Methods (Pre-order, In-order, Post-order)**:
    
    - These methods are public wrappers that call their respective private helper functions, which perform recursive traversals starting from the root.
    - **Pre-order Traversal (`preOrder`)**: **(Root -> Left -> Right)**. It prints the node's data first, then recursively traverses its left subtree, and finally its right subtree.

[![BinTree](G:\DSA\Slides\BinTree-Implement\s13.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s14.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s15.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s16.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s17.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s18.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s19.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s20.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s21.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s22.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s23.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s24.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s25.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s26.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s27.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s28.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s29.png)

- **In-order Traversal (`inOrder`)**: **(Left -> Root -> Right)**. It recursively traverses the left subtree, then prints the node's data, and finally recursively traverses its right subtree.

[![BinTree](G:\DSA\Slides\BinTree-Implement\s30.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s59.png)

- **Post-order Traversal (`postOrder`)**: **(Left -> Right -> Root)**. It recursively traverses the left subtree, then its right subtree, and finally prints the node's data.

[![BinTree](G:\DSA\Slides\BinTree-Implement\s60.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s83.png)


[![BinTree](G:\DSA\Slides\BinTree-Implement\s84.png)

4. **Height Calculation (`getHeight`)**:
    
    - This is a **recursive method** that determines the height of the tree or a subtree.
    - The base case is when a node is `nullptr`, returning 0.
    - For a non-null node, it calculates the height as `1 + max(height of left subtree, height of right subtree)`.

[![BinTree](G:\DSA\Slides\BinTree-Implement\s2.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s3.png)

[![BinTree](G:\DSA\Slides\BinTree-Implement\s11.png)

5. **Finding Elements (`find`, `findHelper`)**:
    
    - The `find` method checks if the tree is empty and then calls `findHelper`.
    - `findHelper` recursively searches for a data element (`_data`) in the tree. It returns `true` if the data is found in the current node, or in its left or right subtrees. Output messages indicate whether the element was found.
6. **Deletion (`deleteNode`, `deleteNodeHelper`)**:
    
    - The `deleteNode` method first checks if the tree is empty or if the element exists.
    - If the element exists, `deleteNodeHelper` is called.
    - The deletion strategy involves:
        1. **Finding the node to delete** (`nodeToDelete`) using a level-order traversal.
        2. **Finding the deepest rightmost node** (`lastNode`) in the entire tree, also via level-order traversal (which `findDeepestRightmost` does).
        3. **Replacing the data** of `nodeToDelete` with the data of `lastNode`.
        4. **Deleting the `lastNode`** by finding its parent and setting the parent's corresponding child pointer (left or right) to `nullptr`, then deallocating `lastNode`.
    - A special case handles deleting the root if it's the only node.

---
### Demonstration

The `main.cpp` file demonstrates the functionality using a `BinaryTree<char>`. It inserts characters 'A' through 'I'. The program then:

- Displays the tree structure.
- Performs pre-order, in-order, and post-order traversals.
- Searches for 'I' (found) and 'J' (not found).
- Deletes 'D' (found) and 'K' (not found).
- Displays the tree structure again after deletions.



---
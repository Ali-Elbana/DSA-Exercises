
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=f21e735e-ea75-4f17-9bfe-c443e27202bd)

---
### Introduction to Heaps

A Heap is a specialized tree-based data structure that satisfies the **heap property**. Heaps are typically implemented as **complete binary trees** and can be efficiently **represented in an array**. There are two main types of heaps:

[![Heap](G:\DSA\Slides\Heap\s3.png)

[![Heap](G:\DSA\Slides\Heap\s4.png)

- **Min-Heap:** In a min-heap, the **parent node's value is always less than or equal to the values of its children**. This means the minimum element is always at the root.
- **Max-Heap:** In a max-heap, the parent node's value is always greater than or equal to the values of its children.

[![Heap](G:\DSA\Slides\Heap\s2.png)

---
### Array Representation of a Heap

Due to their complete binary tree structure, heaps can be stored efficiently in a **dynamic array (e.g., `std::vector` in C++)** without using explicit pointers for connections. For any node at index `i` in the array:

- **Parent Index:** `(i - 1) / 2`.
- **Left Child Index:** `(2 * i) + 1`.
- **Right Child Index:** `(2 * i) + 2`.

This array representation follows a **Breadth First Traversal (Level Order)**, meaning elements are added level by level from left to right.

[![Heap](G:\DSA\Slides\Heap\s5.png)

[![Heap](G:\DSA\Slides\Heap\s7.png)

[![Heap](G:\DSA\Slides\Heap\s8.png)

[![Heap](G:\DSA\Slides\Heap\s9.png)

[![Heap](G:\DSA\Slides\Heap\s10.png)

[![Heap](G:\DSA\Slides\Heap\s11.png)

[![Heap](G:\DSA\Slides\Heap\s12.png)

[![Heap](G:\DSA\Slides\Heap\s13.png)

[![Heap](G:\DSA\Slides\Heap\s14.png)

[![Heap](G:\DSA\Slides\Heap\s15.png)

---
### C++ Min-Heap Implementation

The provided C++ implementation [[10.1.2-Heap â€“ Implementation - Code#Complete Code Implementation]] defines a `Heap` class:

- **Private Data Members:**
    - `std::vector<int> data_list`: A dynamic array used to store the heap elements.
    - `size_t heap_size`: Tracks the current number of elements in the heap.
- **Constructor:** The default constructor initializes an empty heap with `heap_size` set to 0. Its complexity is O(1).

---
### Key Heap Operations

1. **Insert Method (`insert(int data)`)**
    
    - **Purpose:** Adds a new element to the min-heap while maintaining the min-heap property.
    - **Mechanism (Bubble Up/Percolate Up):**
        1. The new element is initially placed at the **next available position at the end of the heap** (the end of the array). If the vector needs more space, it extends.
        2. The element then "bubbles up" (also known as "percolating up") the tree by repeatedly **comparing it with its parent**.
        3. If the new element is **smaller than its parent**, they are **swapped**.
        4. This process **continues upwards** until the element is at the root (index 0) or its parent is smaller than or equal to it, satisfying the min-heap property.
    - **Complexity:** O(log n) due to the upward bubbling process.

[![Heap](G:\DSA\Slides\Heap\s16.png)

[![Heap](G:\DSA\Slides\Heap\s18.png)

[![Heap](G:\DSA\Slides\Heap\s19.png)

[![Heap](G:\DSA\Slides\Heap\s20.png)

[![Heap](G:\DSA\Slides\Heap\s21.png)

[![Heap](G:\DSA\Slides\Heap\s22.png)

[![Heap](G:\DSA\Slides\Heap\s23.png)

[![Heap](G:\DSA\Slides\Heap\s24.png)

[![Heap](G:\DSA\Slides\Heap\s25.png)

[![Heap](G:\DSA\Slides\Heap\s26.png)

[![Heap](G:\DSA\Slides\Heap\s27.png)

2. **Pop Method (`pop()`)**
    
    - **Purpose:** Removes and returns the minimum element from the heap, which is always the root.
    - **Precondition:** Throws `std::out_of_range` if the heap is empty.
    - **Mechanism (Bubble Down/Percolate Down):**
        1. The **minimum value (root) is stored** for return.
        2. The **last element in the heap** is moved to the root position (index 0).
        3. The `heap_size` is then decremented.
        4. The element now at the root "bubbles down" (also known as "percolating down") to restore the min-heap property.
        5. The element is **compared with its children** to find the smaller child.
        6. If the current element is **larger than its smaller child**, they are **swapped**.
        7. This process **continues downwards** until the element has no children (is a leaf) or is smaller than or equal to both its children.
    - **Complexity:** O(log n) due to the downward bubbling process.

[![Heap](G:\DSA\Slides\Heap\s63.png)

[![Heap](G:\DSA\Slides\Heap\s65.png)

[![Heap](G:\DSA\Slides\Heap\s66.png)

[![Heap](G:\DSA\Slides\Heap\s67.png)

[![Heap](G:\DSA\Slides\Heap\s68.png)

[![Heap](G:\DSA\Slides\Heap\s69.png)

[![Heap](G:\DSA\Slides\Heap\s70.png)

[![Heap](G:\DSA\Slides\Heap\s71.png)

[![Heap](G:\DSA\Slides\Heap\s75.png)

[![Heap](G:\DSA\Slides\Heap\s76.png)

---
### Utility Methods

- **`print()`:** Displays all heap elements in linear (array) order. Complexity is O(n).
- **`size()`:** Returns the current number of elements in the heap. Complexity is O(1).
- **`empty()`:** Checks if the heap contains any elements. Complexity is O(1).
- **`draw()`:** Provides a visual representation of the heap as a binary tree using a level-order traversal. Complexity is O(n). It calculates the number of levels using `log2(heap_size) + 1` and determines spacing for visualization.

---
### Demonstration

The `main` function demonstrates the `Heap` class by:

- Creating an empty heap.
- Inserting sample data (5, 3, 8, 1, 6).
- Printing the heap in array representation and drawing its tree structure.
- Extracting all elements using `pop()` until the heap is empty, demonstrating that elements are extracted in sorted (min to max) order.

---
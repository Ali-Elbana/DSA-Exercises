# Min-Heap Implementation

**Author:** Ali El-bana  
**Date:** 2025-08-28  
**Version:** v1.0  
**Language:** C++

## Overview

A complete min-heap implementation using dynamic array storage with insertion, deletion, and tree visualization capabilities. The min-heap property ensures that the parent node is always smaller than or equal to its children.

## Key Features

- **Dynamic Storage**: Uses `std::vector` for automatic memory management
- **Min-Heap Property**: Parent ≤ children at all levels
- **Tree Visualization**: ASCII art representation of heap structure
- **Complete Binary Tree**: Maintains completeness through array-based storage

## Data Structure Properties

|Property|Description|
|---|---|
|**Storage**|Array-based using `std::vector<int>`|
|**Indexing**|Parent: `(i-1)/2`, Left Child: `2*i+1`, Right Child: `2*i+2`|
|**Heap Property**|Min-heap: `parent ≤ children`|
|**Tree Type**|Complete binary tree|

## Methods Overview

### Core Operations

#### `insert(int data)` - O(log n)

- Adds element to the end of heap
- Performs **bubble-up** operation to maintain heap property
- Compares with parent and swaps if necessary

#### `pop()` - O(log n)

- Removes and returns minimum element (root)
- Moves last element to root position
- Performs **bubble-down** operation to restore heap property
- Throws `std::out_of_range` if heap is empty

### Utility Methods

#### `print()` - O(n)

- Displays heap elements in linear array order
- Format: `element1 - element2 - element3 -`

#### `draw()` - O(n)

- Creates ASCII tree visualization
- Uses level-order traversal
- Calculates spacing based on tree depth

#### `size()` - O(1)

- Returns current number of elements

#### `empty()` - O(1)

- Returns `true` if heap is empty

## Algorithm Details

### Insertion Process (Bubble-Up)

1. Add element at end of array
2. Compare with parent node
3. If element < parent, swap positions
4. Repeat until heap property is satisfied or reach root

### Deletion Process (Bubble-Down)

1. Store root value (minimum)
2. Move last element to root
3. Compare with children
4. Swap with smaller child if necessary
5. Repeat until heap property is restored

### Tree Visualization Algorithm

1. Calculate number of levels: `log₂(size) + 1`
2. For each level, calculate spacing and nodes
3. Print nodes with appropriate spacing for tree structure

## Example Usage

```cpp
Heap heap;

// Insert elements
heap.insert(5);
heap.insert(3);
heap.insert(8);
heap.insert(1);
heap.insert(6);

// Display heap
heap.print();  // Output: 1 - 3 - 8 - 5 - 6 - 
heap.draw();   // ASCII tree representation

// Extract minimum elements
while(!heap.empty()) {
    cout << heap.pop() << " ";  // Output: 1 3 5 6 8
}
```

## Time Complexity Analysis

|Operation|Time Complexity|Explanation|
|---|---|---|
|Insert|O(log n)|Bubble-up through tree height|
|Extract Min|O(log n)|Bubble-down through tree height|
|Peek Min|O(1)|Access root element|
|Size|O(1)|Simple variable access|
|Empty Check|O(1)|Simple comparison|
|Print|O(n)|Traverse all elements|
|Draw|O(n)|Process all elements for visualization|

## Space Complexity

- **Storage**: O(n) for storing n elements
- **Auxiliary**: O(1) for all operations (in-place operations)

## Implementation Notes

### Design Decisions

- **Vector vs Array**: Uses `std::vector` for dynamic resizing
- **0-based Indexing**: Standard array indexing for parent/child calculations
- **Exception Handling**: Throws exception for pop() on empty heap
- **Const Correctness**: Read-only methods marked as `const`

### Tree Visualization Details

- Calculates optimal spacing for readability
- Handles incomplete levels gracefully
- Uses string stream for efficient output formatting

## Related Concepts

- **Binary Heap**: Complete binary tree with heap property
- **Priority Queue**: Abstract data type implemented using heaps
- **Heap Sort**: Sorting algorithm using heap operations
- **Max-Heap**: Alternative where parent ≥ children

## Complete Code Implementation

```cpp
/*
============================================================
* Project: Min-Heap Implementation
* File:    main.cpp
* Author:  [Ali El-bana]
* Date:    [2025-08-28]
* Version: v1.0
------------------------------------------------------------
* Description:
* Complete min-heap implementation with insertion, deletion,
* and visual tree representation capabilities
------------------------------------------------------------
* Notes:
* - Implements min-heap property (parent ≤ children)
* - Dynamic array-based storage using std::vector
* - Includes tree visualization functionality
============================================================
*/

/* ====================== Includes ====================== */
#include <iostream>
#include <vector>
#include <cmath>
#include <string>
#include <sstream>
#include <iomanip>

/* =================== Namespace Usage ================== */
using std::cout;
using std::endl;
using std::vector;
using std::string;

/* ===================== Class Definition =============== */
// ▼▼▼ Class: Heap (Min-Heap Implementation) ▼▼▼
class Heap {
private:
    // ▼▼▼ Private Data Members ▼▼▼
    std::vector<int> data_list;  // Dynamic array to store heap elements
    size_t heap_size;            // Current number of elements in heap
    // ▲▲▲ End of Private Data Members ▲▲▲

public:
    // ▼▼▼ Constructor ▼▼▼
    /**
     * @brief Default constructor - initializes empty heap
     * @complexity O(1)
     */
    Heap() : heap_size(0) {}
    // ▲▲▲ End of Constructor ▲▲▲

    // ▼▼▼ Insert Method ▼▼▼
    /**
     * @brief Inserts a new element into the min-heap
     * @param data The integer value to insert
     * @complexity O(log n) - due to upward bubbling
     */
    void insert(int data) 
	{
        // Get insertion position (end of heap)
        size_t i = heap_size;
        
        // Add element to vector (resize if necessary)
        if(i < data_list.size()) 
		{
            data_list[i] = data;        // Reuse existing space
        } 
		else 
		{
            data_list.push_back(data);  // Extend vector
        }
		
        heap_size++;  // Increment heap size
        
        // ▼▼▼ Bubble Up Process (Maintain Min-Heap Property) ▼▼▼
        size_t parent_index = (i - 1) / 2;  // Calculate parent index
        
        // Continue bubbling up while not at root and parent > current
        while(i != 0 && data_list[i] < data_list[parent_index]) 
		{
            // Swap with parent
            std::swap(data_list[i], data_list[parent_index]);
            
            // Move up to parent position
            i = parent_index;
            parent_index = (i - 1) / 2;
        }
        // ▲▲▲ End of Bubble Up Process ▲▲▲
    }
    // ▲▲▲ End of Insert Method ▲▲▲

    // ▼▼▼ Pop Method (Extract Minimum) ▼▼▼
    /**
     * @brief Removes and returns the minimum element (root)
     * @return The minimum element in the heap
     * @throws std::out_of_range if heap is empty
     * @complexity O(log n) - due to downward bubbling
     */
    int pop() 
	{
        // Check if heap is empty
        if(heap_size == 0) 
		{
            throw std::out_of_range("Heap is empty");
        }
        
        // Store minimum value (root) to return
        int data = data_list[0];
        
        // Move last element to root position
        data_list[0] = data_list[heap_size - 1];
        heap_size--;  // Decrease heap size
        
        // ▼▼▼ Bubble Down Process (Restore Min-Heap Property) ▼▼▼
        size_t i = 0;                    // Start from root
        size_t left_index = 2 * i + 1;   // Left child index
        
        // Continue while left child exists
        while(left_index < heap_size) 
		{
            size_t right_index = 2 * i + 2;   // Right child index
            size_t smaller_index = left_index; // Assume left is smaller
            
            // Check if right child exists and is smaller than left
            if(right_index < heap_size && data_list[right_index] < data_list[left_index]) 
			{
                smaller_index = right_index;
            }
            
            // If current element is already smaller than both children, stop
            if(data_list[smaller_index] >= data_list[i]) 
			{
                break;
            }
            
            // Swap with smaller child
            std::swap(data_list[i], data_list[smaller_index]);
            
            // Move down to child position
            i = smaller_index;
            left_index = 2 * i + 1;
        }
        // ▲▲▲ End of Bubble Down Process ▲▲▲
        
        return data;  // Return extracted minimum
    }
    // ▲▲▲ End of Pop Method ▲▲▲

    // ▼▼▼ Print Method (Linear Display) ▼▼▼
    /**
     * @brief Prints all heap elements in linear order
     * @complexity O(n)
     */
    void print() const 
	{
        for(size_t i = 0; i < heap_size; i++) 
		{
            std::cout << data_list[i] << " - ";
        }
        std::cout << "\n";
    }
    // ▲▲▲ End of Print Method ▲▲▲

    // ▼▼▼ Size Method ▼▼▼
    /**
     * @brief Returns the number of elements in the heap
     * @return Current heap size
     * @complexity O(1)
     */
    size_t size() const 
	{
        return heap_size;
    }
    // ▲▲▲ End of Size Method ▲▲▲

    // ▼▼▼ Empty Method ▼▼▼
    /**
     * @brief Checks if the heap is empty
     * @return true if heap is empty, false otherwise
     * @complexity O(1)
     */
    bool empty() const 
	{
        return heap_size == 0;
    }
    // ▲▲▲ End of Empty Method ▲▲▲

    // ▼▼▼ Draw Method (Tree Visualization) ▼▼▼
    /**
     * @brief Draws a visual representation of the heap as a binary tree
     * @complexity O(n)
     * @note Uses level-order traversal for tree representation
     */
    void draw() const 
	{
        // Return if heap is empty
        if (heap_size == 0) return;
        
        // Calculate tree dimensions
        int levels_count = static_cast<int>(std::log2(heap_size)) + 1;  // Number of levels
        int line_width = static_cast<int>(std::pow(2, levels_count - 1)); // Max width needed
        
        size_t j = 0;  // Element index tracker
        
        // ▼▼▼ Level-by-Level Tree Drawing ▼▼▼
        for(int i = 0; i < levels_count; i++) 
		{
            // Calculate nodes at current level
            int nodes_count = static_cast<int>(std::pow(2, i));
            
            // Calculate spacing for centering
            int space = static_cast<int>(std::ceil(line_width - nodes_count / 2.0));
            int space_between = static_cast<int>(std::ceil(levels_count / static_cast<double>(nodes_count)));
            space_between = space_between < 1 ? 1 : space_between;  // Minimum spacing
            
            // Build output string for current level
            std::ostringstream str;
            str << std::string(space + space_between, ' ');  // Leading spaces
            
            size_t k = j;  // Save starting position
            
            // Print all nodes at current level
            for(; j < k + nodes_count; j++) 
			{
                if(j == heap_size) 
				{  // Stop if no more elements
                    break;
                }
                str << data_list[j] << std::string(space_between, ' ');
            }
            
            str << std::string(space, ' ') << "\n";  // Trailing spaces and newline
            std::cout << str.str();  // Output the level
        }
        // ▲▲▲ End of Level-by-Level Tree Drawing ▲▲▲
    }
    // ▲▲▲ End of Draw Method ▲▲▲
};
// ▲▲▲ End of Heap Class ▲▲▲

/* ==================== Main Application ================= */
/**
 * @brief Demonstration program for min-heap functionality
 * @return 0 on successful execution
 */
int main() {
    // ▼▼▼ Heap Creation and Population ▼▼▼
    std::cout << "Min-Heap Demonstration Program" << std::endl;
    std::cout << "===============================" << std::endl;
    
    Heap heap;  // Create empty heap
    
    // Insert sample data
    std::cout << "\nInserting elements: 5, 3, 8, 1, 6" << std::endl;
    heap.insert(5);
    heap.insert(3);
    heap.insert(8);
    heap.insert(1);
    heap.insert(6);
    // ▲▲▲ End of Heap Creation and Population ▲▲▲
    
    // ▼▼▼ Display Heap Contents ▼▼▼
    std::cout << "\nHeap elements (array representation): ";
    heap.print();
    
    std::cout << "\nHeap tree structure:" << std::endl;
    heap.draw();
    // ▲▲▲ End of Display Heap Contents ▲▲▲
    
    // ▼▼▼ Extract All Elements (Heap Sort) ▼▼▼
    std::cout << "\nExtracting elements in sorted order (min to max):" << std::endl;
    while(heap.empty() == false) 
	{
        std::cout << heap.pop() << " ";
    }
    std::cout << std::endl;
    // ▲▲▲ End of Extract All Elements ▲▲▲
    
    std::cout << "\nProgram completed successfully!" << std::endl;
    return 0;
}

/* ======================= End of File =================== */
```
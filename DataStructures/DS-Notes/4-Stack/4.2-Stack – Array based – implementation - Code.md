## üìä Overview

A **Stack** is a linear data structure that follows the **LIFO (Last In, First Out)** principle. Elements are added and removed from the same end, called the "top" of the stack.

### Key Characteristics

- **LIFO Behavior**: Last element added is the first one removed
- **Single Access Point**: Only the top element is directly accessible
- **Dynamic Memory**: Uses dynamic arrays with automatic resizing
- **Template-Based**: Generic implementation for any data type

---

## üîß Core Operations

|Operation|Description|Time Complexity|
|---|---|---|
|`push()`|Add element to top|O(1) amortized|
|`pop()`|Remove and return top element|O(1)|
|`peek()`|View top element without removal|O(1)|
|`isEmpty()`|Check if stack is empty|O(1)|
|`size()`|Get number of elements|O(1)|
|`print()`|Display all elements|O(n)|

---

## üèóÔ∏è Implementation Details

### Memory Management

- **Dynamic Array**: Uses `new[]` and `delete[]` for memory allocation
- **Automatic Resizing**: Doubles capacity when full (growth factor = 2)
- **RAII Compliance**: Proper constructor/destructor/copy semantics
- **Exception Safety**: Handles underflow and invalid operations

### Private Members

```cpp
T* arr;           // Dynamic array storage
int capacity;     // Maximum elements before resize
int topIndex;     // Index of top element (-1 when empty)
```

### Template Design

- **Generic Type Support**: Works with `int`, `string`, `double`, `char`, etc.
- **Explicit Instantiations**: Pre-compiled for common types
- **Type Safety**: Compile-time type checking

---

## üìÅ Project Structure

The implementation is organized into multiple files following good software engineering practices:

### File Organization

#### `Stack.h` - Header File

```cpp
/*
============================================================
* Project: Array-Based Stack Data Structure
* File:    Stack.h
* Author:  [Your Name]
* Date:    2025-08-15
* Version: v1.0
------------------------------------------------------------
* Description:
* Template-based Stack implementation using dynamic arrays
* with automatic resizing capability and full RAII support
------------------------------------------------------------
* Notes:
* - Uses dynamic memory allocation with automatic expansion
* - Thread-safe operations not guaranteed (single-threaded use)
* - Explicit template instantiations provided for common types
============================================================
*/

#ifndef STACK_H
#define STACK_H

/* ====================== Includes ====================== */
#include <iostream>
#include <stdexcept>

/* =================== Namespace Usage ================== */
using std::cout;
using std::endl;

/* =================== Global Constants ================= */
// Default initial capacity for new stacks
const int DEFAULT_CAPACITY = 10;
const int GROWTH_FACTOR = 2;

/* ====================== Declarations ================== */
// ‚ñº‚ñº‚ñº Class: Stack ‚ñº‚ñº‚ñº
template <typename T>
class Stack;
// ‚ñ≤‚ñ≤‚ñ≤ End of Stack ‚ñ≤‚ñ≤‚ñ≤

/* ===================== Class Definitions =============== */
// ‚ñº‚ñº‚ñº Class: Stack ‚ñº‚ñº‚ñº
template <typename T>
class Stack {
private:
    // ----- Private Data Members -----
    T* arr;           // Dynamic array to store stack elements
    int capacity;     // Maximum capacity of the stack
    int topIndex;     // Index of the top element (-1 if empty)
    
    // ----- Private Helper Methods -----
    void resize();    // Helper function to resize the array when needed

public:
    // ----- Constructors & Destructor -----
    explicit Stack(int initialCapacity = DEFAULT_CAPACITY);
    ~Stack();
    Stack(const Stack& other);                    // Copy constructor
    Stack& operator=(const Stack& other);         // Assignment operator
    
    // ----- Core Stack Operations -----
    void push(const T& element);                  // Add element to top
    T pop();                                      // Remove and return top element
    T peek() const;                               // Get top element without removal
    
    // ----- Utility Functions -----
    bool isEmpty() const;                         // Check if stack is empty
    int size() const;                             // Get current number of elements
    void print() const;                           // Display all stack elements
    
    // ----- Additional Utilities -----
    int getCapacity() const;                      // Get current capacity
};
// ‚ñ≤‚ñ≤‚ñ≤ End of Stack ‚ñ≤‚ñ≤‚ñ≤

#endif // STACK_H

/* ======================= End of File =================== */
```

#### `Stack.cpp` - Implementation File

```cpp
/*
============================================================
* Project: Array-Based Stack Data Structure
* File:    Stack.cpp
* Author:  [Your Name]
* Date:    2025-08-15
* Version: v1.0
------------------------------------------------------------
* Description:
* Implementation file for template-based Stack class with
* dynamic array storage and automatic memory management
------------------------------------------------------------
* Notes:
* - All methods include proper exception handling
* - Memory is automatically managed through RAII principles
* - Template instantiations provided at end of file
============================================================
*/

/* ====================== Includes ====================== */
#include "Stack.h"
#include <string>

/* =================== Namespace Usage ================== */
using std::invalid_argument;
using std::underflow_error;
using std::cout;
using std::endl;
using std::string;

/* ================== Method Definitions ================ */

// ‚ñº‚ñº‚ñº Constructor Definition ‚ñº‚ñº‚ñº
template <typename T>
Stack<T>::Stack(int initialCapacity) : capacity(initialCapacity), topIndex(-1) {
    // ----- Input Validation -----
    if (initialCapacity <= 0) {
        throw invalid_argument("Initial capacity must be positive");
    }
    
    // ----- Memory Allocation -----
    arr = new T[capacity];
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Constructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Destructor Definition ‚ñº‚ñº‚ñº
template <typename T>
Stack<T>::~Stack() {
    // ----- Memory Deallocation -----
    delete[] arr;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Destructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Copy Constructor Definition ‚ñº‚ñº‚ñº
template <typename T>
Stack<T>::Stack(const Stack& other) : capacity(other.capacity), topIndex(other.topIndex) {
    // ----- Memory Allocation -----
    arr = new T[capacity];
    
    // ----- Deep Copy Elements -----
    for (int i = 0; i <= topIndex; ++i) {
        arr[i] = other.arr[i];
    }
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Copy Constructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Assignment Operator Definition ‚ñº‚ñº‚ñº
template <typename T>
Stack<T>& Stack<T>::operator=(const Stack& other) {
    // ----- Self-Assignment Check -----
    if (this != &other) {
        // ----- Cleanup Current Resources -----
        delete[] arr;
        
        // ----- Copy New Data -----
        capacity = other.capacity;
        topIndex = other.topIndex;
        arr = new T[capacity];
        
        // ----- Deep Copy Elements -----
        for (int i = 0; i <= topIndex; ++i) {
            arr[i] = other.arr[i];
        }
    }
    return *this;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Assignment Operator ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Resize Helper Method Definition ‚ñº‚ñº‚ñº
template <typename T>
void Stack<T>::resize() {
    // ----- Calculate New Capacity -----
    int newCapacity = capacity * GROWTH_FACTOR;
    T* newArr = new T[newCapacity];
    
    // ----- Copy Existing Elements -----
    for (int i = 0; i <= topIndex; ++i) {
        newArr[i] = arr[i];
    }
    
    // ----- Update Array and Capacity -----
    delete[] arr;
    arr = newArr;
    capacity = newCapacity;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Resize Helper Method ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Push Method Definition ‚ñº‚ñº‚ñº
template <typename T>
void Stack<T>::push(const T& element) {
    // ----- Check if Resize Needed -----
    if (topIndex + 1 >= capacity) {
        resize();
    }
    
    // ----- Add Element to Stack -----
    arr[++topIndex] = element;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Push Method ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Pop Method Definition ‚ñº‚ñº‚ñº
template <typename T>
T Stack<T>::pop() {
    // ----- Validate Stack State -----
    if (isEmpty()) {
        throw underflow_error("Stack is empty - cannot pop");
    }
    
    // ----- Return and Remove Top Element -----
    return arr[topIndex--];
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Pop Method ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Peek Method Definition ‚ñº‚ñº‚ñº
template <typename T>
T Stack<T>::peek() const {
    // ----- Validate Stack State -----
    if (isEmpty()) {
        throw underflow_error("Stack is empty - cannot peek");
    }
    
    // ----- Return Top Element -----
    return arr[topIndex];
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Peek Method ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº isEmpty Method Definition ‚ñº‚ñº‚ñº
template <typename T>
bool Stack<T>::isEmpty() const {
    // ----- Check if Stack is Empty -----
    return topIndex == -1;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of isEmpty Method ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Size Method Definition ‚ñº‚ñº‚ñº
template <typename T>
int Stack<T>::size() const {
    // ----- Return Current Size -----
    return topIndex + 1;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Size Method ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Print Method Definition ‚ñº‚ñº‚ñº
template <typename T>
void Stack<T>::print() const {
    // ----- Handle Empty Stack -----
    if (isEmpty()) {
        cout << "Stack is empty" << endl;
        return;
    }
    
    // ----- Display Stack Contents -----
    cout << "Stack contents (top to bottom): ";
    for (int i = topIndex; i >= 0; --i) {
        cout << arr[i];
        if (i > 0) cout << " -> ";
    }
    cout << endl;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Print Method ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº GetCapacity Method Definition ‚ñº‚ñº‚ñº
template <typename T>
int Stack<T>::getCapacity() const {
    // ----- Return Current Capacity -----
    return capacity;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of GetCapacity Method ‚ñ≤‚ñ≤‚ñ≤

/* ============== Template Instantiations =============== */
// ----- Explicit Template Instantiations for Common Types -----
template class Stack<int>;
template class Stack<double>;
template class Stack<char>;
template class Stack<string>;

/* ======================= End of File =================== */
```

#### `main.cpp` - Demo Program

```cpp
/*
============================================================
* Project: Array-Based Stack Data Structure
* File:    main.cpp
* Author:  [Your Name]
* Date:    2025-08-15
* Version: v1.0
------------------------------------------------------------
* Description:
* Demonstration program showing Stack implementation usage
* with various data types and comprehensive testing
------------------------------------------------------------
* Notes:
* - Includes error handling demonstrations
* - Tests dynamic resizing functionality
* - Shows usage with different data types
============================================================
*/

/* ====================== Includes ====================== */
#include "Stack.h"
#include <iostream>
#include <string>
#include <exception>

/* =================== Namespace Usage ================== */
using std::cout;
using std::cin;
using std::endl;
using std::string;
using std::exception;

/* =================== Global Constants ================= */
// Demo configuration constants
const int INITIAL_SMALL_CAPACITY = 3;

/* ==================== Function Prototypes ============== */
// ‚ñº‚ñº‚ñº Function: demonstrateIntStack ‚ñº‚ñº‚ñº
void demonstrateIntStack();
// ‚ñ≤‚ñ≤‚ñ≤ End of demonstrateIntStack ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Function: demonstrateStringStack ‚ñº‚ñº‚ñº
void demonstrateStringStack();
// ‚ñ≤‚ñ≤‚ñ≤ End of demonstrateStringStack ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Function: demonstrateErrorHandling ‚ñº‚ñº‚ñº
void demonstrateErrorHandling();
// ‚ñ≤‚ñ≤‚ñ≤ End of demonstrateErrorHandling ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Function: printSectionHeader ‚ñº‚ñº‚ñº
void printSectionHeader(const string& title);
// ‚ñ≤‚ñ≤‚ñ≤ End of printSectionHeader ‚ñ≤‚ñ≤‚ñ≤

/* ==================== Main Application ================= */
int main(void) {
    // ----- Initialization -----
    system("cls"); // Clear console (Windows)
    // system("clear"); // Uncomment for Linux/Mac
    
    cout << "Stack Data Structure Implementation Demo" << endl;
    cout << "=======================================" << endl << endl;
    
    // ----- Demo Logic -----
    demonstrateIntStack();
    demonstrateStringStack(); 
    demonstrateErrorHandling();
    
    // ----- Program End -----
    cout << "Demo completed successfully!" << endl;
    return 0;
}

/* ================== Function/Method Definitions =============== */

// ‚ñº‚ñº‚ñº demonstrateIntStack Definition ‚ñº‚ñº‚ñº
void demonstrateIntStack() {
    printSectionHeader("Integer Stack Demo");
    
    // ----- Create Stack with Small Initial Capacity -----
    Stack<int> intStack(INITIAL_SMALL_CAPACITY);
    
    // ----- Test Push Operations -----
    cout << "Pushing elements: 10, 20, 30, 40, 50" << endl;
    intStack.push(10);
    intStack.push(20);
    intStack.push(30);
    intStack.push(40);
    intStack.push(50);
    
    // ----- Display Stack Information -----
    intStack.print();
    cout << "Size: " << intStack.size() << endl;
    cout << "Capacity: " << intStack.getCapacity() << endl;
    
    // ----- Test Peek Operation -----
    cout << "Top element (peek): " << intStack.peek() << endl;
    
    // ----- Test Pop Operations -----
    cout << "\nPopping elements:" << endl;
    while (!intStack.isEmpty()) {
        cout << "Popped: " << intStack.pop() << endl;
        cout << "Remaining size: " << intStack.size() << endl;
    }
    
    // ----- Final State Check -----
    cout << "Is empty: " << (intStack.isEmpty() ? "Yes" : "No") << endl;
    intStack.print();
    cout << endl;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of demonstrateIntStack ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº demonstrateStringStack Definition ‚ñº‚ñº‚ñº
void demonstrateStringStack() {
    printSectionHeader("String Stack Demo");
    
    // ----- Create String Stack -----
    Stack<string> stringStack;
    
    // ----- Add String Elements -----
    stringStack.push("First");
    stringStack.push("Second");
    stringStack.push("Third");
    
    // ----- Display and Test Operations -----
    stringStack.print();
    
    cout << "Peek: " << stringStack.peek() << endl;
    cout << "Pop: " << stringStack.pop() << endl;
    
    stringStack.print();
    cout << endl;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of demonstrateStringStack ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº demonstrateErrorHandling Definition ‚ñº‚ñº‚ñº
void demonstrateErrorHandling() {
    printSectionHeader("Error Handling Demo");
    
    // ----- Create Empty Stack -----
    Stack<int> emptyStack;
    
    // ----- Test Peek on Empty Stack -----
    try {
        cout << "Trying to peek empty stack..." << endl;
        emptyStack.peek();
    } catch (const exception& e) {
        cout << "Caught exception: " << e.what() << endl;
    }
    
    // ----- Test Pop on Empty Stack -----
    try {
        cout << "Trying to pop from empty stack..." << endl;
        emptyStack.pop();
    } catch (const exception& e) {
        cout << "Caught exception: " << e.what() << endl;
    }
    
    cout << endl;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of demonstrateErrorHandling ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº printSectionHeader Definition ‚ñº‚ñº‚ñº
void printSectionHeader(const string& title) {
    // ----- Print Formatted Section Header -----
    cout << "=== " << title << " ===" << endl;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of printSectionHeader ‚ñ≤‚ñ≤‚ñ≤

/* ======================= End of File =================== */
```

#### `Makefile` - Build Configuration

```makefile
#
#============================================================
# Project: Array-Based Stack Data Structure
# File:    Makefile
# Author:  [Your Name]
# Date:    2025-08-15
# Version: v1.0
#------------------------------------------------------------
# Description:
# Build configuration for Stack implementation with
# compilation rules, dependencies, and utility targets
#------------------------------------------------------------
# Notes:
# - Supports both debug and release builds
# - Includes automatic dependency tracking
# - Cross-platform compatible (Linux/Windows/Mac)
#============================================================

# ====================== Build Configuration ======================
# ----- Compiler Settings -----
CXX = g++
CXXFLAGS = -std=c++17 -Wall -Wextra -O2

# ----- Project Files -----
TARGET = stack_demo
SOURCES = main.cpp Stack.cpp
OBJECTS = $(SOURCES:.cpp=.o)
HEADERS = Stack.h

# ----- Build Directories -----
BUILD_DIR = build
OBJ_DIR = $(BUILD_DIR)/obj

# ====================== Build Targets ======================

# ----- Default Target -----
all: $(TARGET)
	@echo "Build completed successfully!"

# ----- Main Executable -----
$(TARGET): $(OBJECTS)
	@echo "Linking executable: $@"
	$(CXX) $(CXXFLAGS) -o $@ $^

# ----- Object Files -----
%.o: %.cpp $(HEADERS)
	@echo "Compiling: $<"
	$(CXX) $(CXXFLAGS) -c $< -o $@

# ====================== Utility Targets ======================

# ----- Clean Build Artifacts -----
clean:
	@echo "Cleaning build artifacts..."
	rm -f $(OBJECTS) $(TARGET)
	@echo "Clean completed!"

# ----- Run Program -----
run: $(TARGET)
	@echo "Running program..."
	./$(TARGET)

# ----- Debug Build -----
debug: CXXFLAGS += -g -DDEBUG -O0
debug: $(TARGET)
	@echo "Debug build completed!"

# ----- Release Build -----
release: CXXFLAGS += -O3 -DNDEBUG
release: $(TARGET)
	@echo "Release build completed!"

# ----- Rebuild Everything -----
rebuild: clean all

# ----- Installation (Optional) -----
install: $(TARGET)
	@echo "Installing to /usr/local/bin/"
	sudo cp $(TARGET) /usr/local/bin/

# ----- Show Help -----
help:
	@echo "Available targets:"
	@echo "  all      - Build the project (default)"
	@echo "  clean    - Remove build artifacts"
	@echo "  run      - Build and run the program"
	@echo "  debug    - Build with debug symbols"
	@echo "  release  - Build optimized release version"
	@echo "  rebuild  - Clean and build"
	@echo "  install  - Install to system (requires sudo)"
	@echo "  help     - Show this help message"

# ----- Phony Targets -----
.PHONY: all clean run debug release rebuild install help

#======================= End of File ===================
```

---

## üöÄ Usage Examples

### Basic Usage

```cpp
// Create a stack for integers
Stack<int> myStack;

// Push elements
myStack.push(10);
myStack.push(20);
myStack.push(30);

// Access top element
int top = myStack.peek();  // Returns 30

// Remove elements
int popped = myStack.pop(); // Returns 30
```

### Advanced Operations

```cpp
// Create stack with custom capacity
Stack<string> stringStack(5);

// Check stack status
if (!stringStack.isEmpty()) {
    cout << "Stack size: " << stringStack.size() << endl;
    stringStack.print();
}

// Exception handling
try {
    stringStack.pop(); // May throw underflow_error
} catch (const std::exception& e) {
    cout << "Error: " << e.what() << endl;
}
```

---

## üîÑ Build and Run

### Compilation Commands

```bash
# Basic build
make

# Run the demo
make run

# Debug build with symbols
make debug

# Optimized release build  
make release

# Clean build artifacts
make clean
```

### Manual Compilation

```bash
g++ -std=c++17 -Wall -Wextra -O2 main.cpp Stack.cpp -o stack_demo
./stack_demo
```

---

## üìù Key Learning Points

### Memory Management

- **Dynamic Allocation**: Uses `new[]` and `delete[]` for array management
- **Automatic Expansion**: Doubles capacity when full to maintain O(1) amortized push
- **Deep Copy Semantics**: Proper copy constructor and assignment operator
- **Exception Safety**: No memory leaks even when exceptions occur

### Template Programming

- **Generic Design**: Single implementation works for all data types
- **Explicit Instantiation**: Pre-compiled versions for common types
- **Type Safety**: Compile-time error checking prevents type mismatches

### Error Handling

- **Input Validation**: Constructor checks for valid capacity
- **State Validation**: Pop/peek operations verify non-empty state
- **Standard Exceptions**: Uses `std::underflow_error` and `std::invalid_argument`

---

## üìö References

- **Time Complexity**: All core operations are O(1) except resize (O(n) but amortized O(1))
- **Space Complexity**: O(n) where n is the number of elements
- **C++ Standards**: Complies with C++17 standards and best practices

---

_Tags: #DataStructures #Stack #Templates #MemoryManagement #LIFO #DynamicArrays_

**Author:** Ali El-bana  
**Date:** 2025-08-14  
**Version:** v1.0  
**File:** Stack-LList.cpp

## Overview

This is a custom implementation of a **Stack** data structure using a linked list as the underlying storage mechanism. The implementation is template-based, allowing it to work with any data type, and provides all standard stack operations following the LIFO (Last In, First Out) principle.

## Key Features

- **Template-based**: Generic implementation supporting any data type
- **Linked List Foundation**: Uses a custom `LinkedList<T>` class for storage
- **Complete Stack Interface**: All standard stack operations implemented
- **Memory Management**: Proper constructors, destructor, and assignment operators
- **Educational Focus**: Well-documented code structure for learning purposes

## Complete Code Implementation

```cpp
/*
============================================================
* Project: [Stack Linked List based]
* File:    [Stack-LList.cpp]
* Author:  [Ali El-bana]
* Date:    [2025-08-14]
* Version: [v1.0]
------------------------------------------------------------
* Description:
* [Self implementation of a stack based linked list]
------------------------------------------------------------
* Notes:
* [This is for an educational purpose]
============================================================
*/

/* ====================== Includes ====================== */
#include <iostream>
#include <vector>
#include <string>
#include "GS-LList.cpp"

/* =================== Namespace Usage ================== */
using std::cout;
using std::cin;
using std::endl;

/* ====================== Declarations ================== */
// ▼▼▼ Template Class: Stack ▼▼▼
template<typename T>
class Stack ;
// ▲▲▲ End of Stack ▲▲▲

/* ===================== Class Definitions =============== */
// ▼▼▼ Template Class: Stack ▼▼▼
template<typename T>
class Stack 
{
private:
    LinkedList<T> list; // Using our generic linked list as the underlying data structure
    
public:
    // Constructor
    Stack();
    
    // Copy Constructor
    Stack(const Stack<T>& other);
    
    // Copy Assignment Operator
    Stack<T>& operator=(const Stack<T>& other);
    
    // Destructor
    ~Stack();
    
    // Method Declarations:
    
    // ▼▼▼ Core Stack Operations ▼▼▼
    void push(const T& value);                 // Push element onto the stack
    bool pop();                                // Pop element from the stack
    T peek() const;                            // Get top element without removing it
    // ▲▲▲ End of Core Stack Operations ▲▲▲
    
    // ▼▼▼ Utility Methods ▼▼▼
    bool isEmpty() const;                      // Check if stack is empty
    size_t size() const;                       // Get number of elements in stack
    void print() const;                        // Print all elements in the stack
    void clear();                              // Clear all elements from stack
    // ▲▲▲ End of Utility Methods ▲▲▲
};
// ▲▲▲ End of Stack ▲▲▲

/* ==================== Function Prototypes ============== */
// ▼▼▼ Function: testStackOperations ▼▼▼
template<typename T>
void testStackOperations();
// ▲▲▲ End of testStackOperations ▲▲▲

/* ==================== Main Application ================= */
int main(void) 
{
    // ----- Initialization -----
    system("cls");
    cout << "Program started...\n";
    
    // ----- Logic -----
    
    // Test with integers
    cout << "\n========== Testing Stack with Integers ==========\n";
    testStackOperations<int>();
    
    // Test with strings
    cout << "\n========== Testing Stack with Strings ==========\n";
    testStackOperations<std::string>();
    
    // Test with characters
    cout << "\n========== Testing Stack with Characters ==========\n";
    testStackOperations<char>();
	
    // ----- End -----
    return 0;
}

/* ================== Function/Method Definitions =============== */

// ▼▼▼ Stack Constructor ▼▼▼
template<typename T>
Stack<T>::Stack() : list()
{
}
// ▲▲▲ End of Stack Constructor ▲▲▲

// ▼▼▼ Stack Copy Constructor ▼▼▼
template<typename T>
Stack<T>::Stack(const Stack<T>& other) : list(other.list)
{
}
// ▲▲▲ End of Stack Copy Constructor ▲▲▲

// ▼▼▼ Stack Copy Assignment Operator ▼▼▼
template<typename T>
Stack<T>& Stack<T>::operator=(const Stack<T>& other)
{
    if(this != &other)
    {
        list = other.list;
    }
    return *this;
}
// ▲▲▲ End of Stack Copy Assignment Operator ▲▲▲

// ▼▼▼ Stack Destructor ▼▼▼
template<typename T>
Stack<T>::~Stack()
{
    // LinkedList destructor will handle cleanup automatically
}
// ▲▲▲ End of Stack Destructor ▲▲▲

// ▼▼▼ Method: push ▼▼▼
template<typename T>
void Stack<T>::push(const T& value)
{
	list.insertFirst(value);
}
// ▲▲▲ End of push ▲▲▲

// ▼▼▼ Method: pop ▼▼▼
template<typename T>
bool Stack<T>::pop()
{
	bool isDeleted{false};
	
	if(list.isEmpty() == true)
	{
		cout << "\nStack is empty, cannot pop.";
		isDeleted = false;
	}
	else
	{
		list.deleteHead();
		isDeleted = true;
	}
	
	return isDeleted;
}
// ▲▲▲ End of pop ▲▲▲

// ▼▼▼ Method: peek ▼▼▼
template<typename T>
T Stack<T>::peek() const
{
	T result = T(); // default constructed value
	
    if(list.isEmpty() == true)
    {
        cout << "\nStack is empty, cannot peek.";
        result = T(); // Return default constructed value
    }
    else
	{
		result = list.getFirst(); // Get the first element (top of stack)
	}
    return result;
}
// ▲▲▲ End of peek ▲▲▲

// ▼▼▼ Method: isEmpty ▼▼▼
template<typename T>
bool Stack<T>::isEmpty() const
{
	return list.isEmpty();
}
// ▲▲▲ End of isEmpty ▲▲▲

// ▼▼▼ Method: size ▼▼▼
template<typename T>
size_t Stack<T>::size() const
{
    return list.getLength();
}
// ▲▲▲ End of size ▲▲▲

// ▼▼▼ Method: print ▼▼▼
template<typename T>
void Stack<T>::print() const
{
    if(list.isEmpty() == true)
    {
        cout << "\nStack is empty.\n";
        return;
    }
    else
	{
		cout << "\nStack (top to bottom): ";
		list.printList();
	}
}
// ▲▲▲ End of print ▲▲▲

// ▼▼▼ Method: clear ▼▼▼
template<typename T>
void Stack<T>::clear()
{
    list.clear();
}
// ▲▲▲ End of clear ▲▲▲

// ▼▼▼ testStackOperations Definition ▼▼▼
template<typename T>
void testStackOperations()
{
    if constexpr (std::is_same_v<T, int>)
    {
        Stack<int> stack;
        
        cout << "\n=== Testing Integer Stack ===";
        cout << "\nPushing elements: 10, 20, 30, 40";
        stack.push(10);
        stack.push(20);
        stack.push(30);
        stack.push(40);
        
        cout << "\nStack contents:";
        stack.print();
        
        cout << "\nStack size: " << stack.size();
        cout << "\nTop element (peek): " << stack.peek();
        
        cout << "\n\nPopping one element...";
        stack.pop();
        cout << "\nStack after pop:";
        stack.print();
        cout << "\nNew top element: " << stack.peek();
        
        cout << "\n\nPopping all remaining elements:";
        while(!stack.isEmpty())
        {
            cout << "\nPopped: " << stack.peek();
            stack.pop();
        }
        
        cout << "\nStack is now empty: " << (stack.isEmpty() ? "Yes" : "No");
        stack.print();
    }
    else if constexpr (std::is_same_v<T, std::string>)
    {
        Stack<std::string> stack;
        
        cout << "\n=== Testing String Stack ===";
        cout << "\nPushing elements: \"Hello\", \"World\", \"Stack\", \"Test\"";
        stack.push("Hello");
        stack.push("World");
        stack.push("Stack");
        stack.push("Test");
        
        cout << "\nStack contents:";
        stack.print();
        
        cout << "\nStack size: " << stack.size();
        cout << "\nTop element (peek): " << stack.peek();
        
        cout << "\n\nPopping two elements:";
        cout << "\nPopped: " << stack.peek();
        stack.pop();
        cout << "\nPopped: " << stack.peek();
        stack.pop();
        
        cout << "\nRemaining stack:";
        stack.print();
    }
    else if constexpr (std::is_same_v<T, char>)
    {
        Stack<char> stack;
        
        cout << "\n=== Testing Character Stack ===";
        cout << "\nPushing elements: 'A', 'B', 'C', 'D'";
        stack.push('A');
        stack.push('B');
        stack.push('C');
        stack.push('D');
        
        cout << "\nStack contents:";
        stack.print();
        
        cout << "\nStack size: " << stack.size();
        cout << "\nTop element (peek): " << stack.peek();
        
        cout << "\n\nTesting stack reversal:";
        cout << "\nPopping all elements: ";
        while(!stack.isEmpty())
        {
            cout << stack.peek() << " ";
            stack.pop();
        }
        cout << "\n";
        
        cout << "\nStack is now empty: " << (stack.isEmpty() ? "Yes" : "No");
    }
}
// ▲▲▲ End of testStackOperations ▲▲▲

/* ======================= End of File =================== */
```

## Class Structure

### Core Components

```cpp
template<typename T>
class Stack 
{
private:
    LinkedList<T> list; // Underlying linked list storage
    
public:
    // Constructors and destructor
    Stack();
    Stack(const Stack<T>& other);
    Stack<T>& operator=(const Stack<T>& other);
    ~Stack();
    
    // Stack operations
    void push(const T& value);
    bool pop();
    T peek() const;
    
    // Utility methods
    bool isEmpty() const;
    size_t size() const;
    void print() const;
    void clear();
};
```

## Core Operations

### 1. Push Operation

- **Purpose**: Add an element to the top of the stack
- **Implementation**: Uses `list.insertFirst(value)`
- **Time Complexity**: O(1)
- **Usage**: `stack.push(value)`

### 2. Pop Operation

- **Purpose**: Remove the top element from the stack
- **Returns**: `bool` indicating success/failure
- **Behavior**: Returns `false` and prints error if stack is empty
- **Implementation**: Uses `list.deleteHead()`
- **Time Complexity**: O(1)

### 3. Peek Operation

- **Purpose**: View the top element without removing it
- **Returns**: Top element value, or default-constructed value if empty
- **Implementation**: Uses `list.getFirst()`
- **Time Complexity**: O(1)

## Utility Methods

### Status Checking

- `isEmpty()`: Returns `true` if stack has no elements
- `size()`: Returns number of elements in stack

### Data Management

- `clear()`: Removes all elements from stack
- `print()`: Displays all stack elements from top to bottom

## Memory Management

### Rule of Three Implementation

1. **Copy Constructor**: Deep copy of underlying linked list
2. **Copy Assignment Operator**: Self-assignment safe with deep copy
3. **Destructor**: Automatic cleanup via LinkedList destructor

```cpp
// Copy constructor
Stack(const Stack<T>& other) : list(other.list) {}

// Assignment operator with self-assignment check
Stack<T>& operator=(const Stack<T>& other) {
    if(this != &other) {
        list = other.list;
    }
    return *this;
}
```

## Testing Framework

The code includes comprehensive testing for multiple data types:

### Supported Test Types

- **Integers**: Basic numeric operations
- **Strings**: Text-based stack operations
- **Characters**: Character manipulation and reversal

### Test Scenarios

1. **Basic Operations**: Push, pop, peek functionality
2. **Edge Cases**: Empty stack handling
3. **Size Tracking**: Element count verification
4. **Complete Emptying**: Sequential pop operations
5. **Type-Specific**: Tailored tests per data type

## Usage Examples

### Integer Stack

```cpp
Stack<int> intStack;
intStack.push(10);
intStack.push(20);
intStack.push(30);
cout << intStack.peek(); // Output: 30
intStack.pop();          // Removes 30
cout << intStack.size(); // Output: 2
```

### String Stack

```cpp
Stack<std::string> stringStack;
stringStack.push("Hello");
stringStack.push("World");
stringStack.print();     // Shows: World, Hello
```

## Design Decisions

### Why Linked List?

- **Dynamic Size**: No fixed capacity limitations
- **Memory Efficiency**: Allocates only needed space
- **Reusability**: Leverages existing LinkedList implementation

### Template Design

- **Type Safety**: Compile-time type checking
- **Flexibility**: Single implementation for all types
- **Performance**: No runtime type overhead

## Dependencies

- **LinkedList Class**: Custom generic linked list implementation
- **Standard Headers**: `<iostream>`, `<vector>`, `<string>`
- **C++17 Features**: Uses `constexpr if` in testing

## Educational Value

This implementation demonstrates:

- **Data Structure Composition**: Stack built on linked list
- **Template Programming**: Generic C++ design patterns
- **Memory Management**: Proper resource handling
- **Testing Methodology**: Comprehensive validation approach
- **Code Organization**: Clean, documented structure

## Error Handling

- **Empty Stack Operations**: Graceful degradation with error messages
- **Type Safety**: Template system prevents type mismatches
- **Self-Assignment**: Protected copy assignment operator

## Performance Characteristics

|Operation|Time Complexity|Space Complexity|
|---|---|---|
|Push|O(1)|O(1)|
|Pop|O(1)|O(1)|
|Peek|O(1)|O(1)|
|Size|O(1)|O(1)|
|IsEmpty|O(1)|O(1)|

## Extensions and Improvements

Potential enhancements:

- **Iterator Support**: Range-based for loop compatibility
- **Exception Handling**: Throw exceptions instead of returning defaults
- **Move Semantics**: C++11 move constructor and assignment
- **Emplace Operations**: Construct elements in-place
- **Comparison Operators**: Stack equality comparison

---

_This implementation serves as an excellent educational example of how to build a stack data structure from scratch using composition with a linked list, demonstrating both fundamental computer science concepts and modern C++ programming practices._
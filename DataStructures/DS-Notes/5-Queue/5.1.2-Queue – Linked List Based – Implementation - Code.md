## üìä Overview

A **Queue** is a linear data structure that follows the **FIFO (First In, First Out)** principle. Elements are added at the rear (enqueue) and removed from the front (dequeue), similar to a real-world queue of people waiting in line.

### Key Characteristics

- **FIFO Behavior**: First element added is the first one removed
- **Dual Access Points**: Enqueue at rear, dequeue from front
- **Linked List Implementation**: Uses an underlying generic linked list for storage
- **Template-Based**: Generic implementation supporting any data type

---

## üîß Core Operations

|Operation|Description|Time Complexity|
|---|---|---|
|`enqueue(T)`|Add element to rear of queue|O(1)|
|`dequeue()`|Remove and return front element|O(1)|
|`peek()`|View front element without removal|O(1)|
|`isEmpty()`|Check if queue is empty|O(1)|
|`size()`|Get number of elements|O(n)|
|`print()`|Display all elements|O(n)|
|`clear()`|Remove all elements|O(n)|

---

## üèóÔ∏è Implementation Details

### Underlying Structure

- **Composition Pattern**: Uses `LinkedList<T>` as the internal storage mechanism
- **Front Operations**: Dequeue operations work on the head of the linked list
- **Rear Operations**: Enqueue operations work on the tail of the linked list
- **Memory Management**: Delegated to the underlying linked list implementation

### Private Members

```cpp
LinkedList<T> list; // Generic linked list as underlying data structure
```

### Template Design

- **Generic Type Support**: Works with `int`, `string`, `char`, and custom types
- **Compile-time Type Checking**: Uses `std::is_same_v` for type-specific testing
- **RAII Compliance**: Proper copy constructor, assignment operator, and destructor

---

## üìÅ Complete Code Implementation

### `Queue-LList.cpp` - Main Implementation File

```cpp
/*
============================================================
* Project: [Queue Linked List based]
* File:    [Queue-LList.cpp]
* Author:  [Ali El-bana]
* Date:    [2025-08-15]
* Version: [v1.0]
------------------------------------------------------------
* Description:
* [Self implementation of a queue based linked list]
------------------------------------------------------------
* Notes:
* [This is for an educational purpose]
============================================================
*/

/* ====================== Includes ====================== */
#include <iostream>
#include <vector>
#include <string>
#include "GS-LList.cpp"

/* =================== Namespace Usage ================== */
using std::cout;
using std::cin;
using std::endl;


/* =================== Global Constants ================= */
// const double PI = 3.14159;

/* ====================== Declarations ================== */
// ‚ñº‚ñº‚ñº Template Class: Queue ‚ñº‚ñº‚ñº
template<typename T>
class Queue ;
// ‚ñ≤‚ñ≤‚ñ≤ End of Queue ‚ñ≤‚ñ≤‚ñ≤

/* ===================== Class Definitions =============== */
// ‚ñº‚ñº‚ñº Template Class: Queue ‚ñº‚ñº‚ñº
template<typename T>
class Queue 
{
private:
    LinkedList<T> list; // Using our generic linked list as the underlying data structure
    
public:
    // Constructor
    Queue();
    
    // Copy Constructor
    Queue(const Queue<T>& other);
    
    // Copy Assignment Operator
    Queue<T>& operator=(const Queue<T>& other);
    
    // Destructor
    ~Queue();
    
    // Method Declarations:
    
    // ‚ñº‚ñº‚ñº Core Queue Operations ‚ñº‚ñº‚ñº
    void enqueue(const T& value);                 // enqueue element onto the Queue
    T dequeue();                                 // dequeue element from the Queue
    T peek() const;                             // Get top element without removing it
    // ‚ñ≤‚ñ≤‚ñ≤ End of Core Queue Operations ‚ñ≤‚ñ≤‚ñ≤
    
    // ‚ñº‚ñº‚ñº Utility Methods ‚ñº‚ñº‚ñº
    bool isEmpty() const;                      // Check if Queue is empty
    size_t size() const;                       // Get number of elements in Queue
    void print() const;                        // Print all elements in the Queue
    void clear();                              // Clear all elements from Queue
    // ‚ñ≤‚ñ≤‚ñ≤ End of Utility Methods ‚ñ≤‚ñ≤‚ñ≤
};
// ‚ñ≤‚ñ≤‚ñ≤ End of Queue ‚ñ≤‚ñ≤‚ñ≤


/* ==================== Function Prototypes ============== */
// ‚ñº‚ñº‚ñº Function: testQueueOperations ‚ñº‚ñº‚ñº
template<typename T>
void testQueueOperations();
// ‚ñ≤‚ñ≤‚ñ≤ End of testQueueOperations ‚ñ≤‚ñ≤‚ñ≤


/* ==================== Main Application ================= */
int main(void) 
{
    // ----- Initialization -----
    system("cls");
    cout << "Program started...\n";
    
    // ----- Logic -----
    
    // Test with integers
    cout << "\n========== Testing Queue with Integers ==========\n";
    testQueueOperations<int>();
    
    // Test with strings
    cout << "\n========== Testing Queue with Strings ==========\n";
    testQueueOperations<std::string>();
    
    // Test with characters
    cout << "\n========== Testing Queue with Characters ==========\n";
    testQueueOperations<char>();
	
    // ----- End -----
    return 0;
}

/* ================== Function/Method Definitions =============== */

// ‚ñº‚ñº‚ñº Queue Constructor ‚ñº‚ñº‚ñº
template<typename T>
Queue<T>::Queue() : list()
{
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Queue Constructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Queue Copy Constructor ‚ñº‚ñº‚ñº
template<typename T>
Queue<T>::Queue(const Queue<T>& other) : list(other.list)
{
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Queue Copy Constructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Queue Copy Assignment Operator ‚ñº‚ñº‚ñº
template<typename T>
Queue<T>& Queue<T>::operator=(const Queue<T>& other)
{
    if(this != &other)
    {
        list = other.list;
    }
    return *this;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Queue Copy Assignment Operator ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Queue Destructor ‚ñº‚ñº‚ñº
template<typename T>
Queue<T>::~Queue()
{
    // LinkedList destructor will handle cleanup automatically
}
// ‚ñ≤‚ñ≤‚ñ≤ End of Queue Destructor ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Method: enqueue ‚ñº‚ñº‚ñº
template<typename T>
void Queue<T>::enqueue(const T& value)
{
	list.insertLast(value);
}
// ‚ñ≤‚ñ≤‚ñ≤ End of enqueue ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Method: dequeue ‚ñº‚ñº‚ñº
template<typename T>
T Queue<T>::dequeue()
{
	T result = T();
	
	if(list.isEmpty() == true)
	{
		cout << "\nQueue is empty, cannot dequeue.";
		result = T();
	}
	else
	{
		result = list.getFirst(); // Get the first element (top of Queue)
		list.deleteHead();
	}
	
	return result;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of dequeue ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Method: peek ‚ñº‚ñº‚ñº
template<typename T>
T Queue<T>::peek() const
{
	T result = T(); // default constructed value
	
    if(list.isEmpty() == true)
    {
        cout << "\nQueue is empty, cannot peek.";
        result = T(); // Return default constructed value
    }
    else
	{
		result = list.getFirst(); // Get the first element (top of Queue)
	}
    return result;
}
// ‚ñ≤‚ñ≤‚ñ≤ End of peek ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Method: isEmpty ‚ñº‚ñº‚ñº
template<typename T>
bool Queue<T>::isEmpty() const
{
	return list.isEmpty();
}
// ‚ñ≤‚ñ≤‚ñ≤ End of isEmpty ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Method: size ‚ñº‚ñº‚ñº
template<typename T>
size_t Queue<T>::size() const
{
    return list.getLength();
}
// ‚ñ≤‚ñ≤‚ñ≤ End of size ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Method: print ‚ñº‚ñº‚ñº
template<typename T>
void Queue<T>::print() const
{
    if(list.isEmpty() == true)
    {
        cout << "\nQueue is empty.\n";
        return;
    }
    else
	{
		cout << "\nQueue (top to bottom): ";
		list.printList();
	}
}
// ‚ñ≤‚ñ≤‚ñ≤ End of print ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº Method: clear ‚ñº‚ñº‚ñº
template<typename T>
void Queue<T>::clear()
{
    list.clear();
}
// ‚ñ≤‚ñ≤‚ñ≤ End of clear ‚ñ≤‚ñ≤‚ñ≤

// ‚ñº‚ñº‚ñº testQueueOperations Definition ‚ñº‚ñº‚ñº
template<typename T>
void testQueueOperations()
{
    if constexpr (std::is_same_v<T, int>)
    {
        Queue<int> Queue;
        
        cout << "\n=== Testing Integer Queue ===";
        cout << "\nenqueueing elements: 10, 20, 30, 40";
        Queue.enqueue(10);
        Queue.enqueue(20);
        Queue.enqueue(30);
        Queue.enqueue(40);
        
        cout << "\nQueue contents:";
        Queue.print();
        
        cout << "\nQueue size: " << Queue.size();
        cout << "\nTop element (peek): " << Queue.peek();
        
        cout << "\n\ndequeueping one element...";
        Queue.dequeue();
        cout << "\nQueue after dequeue:";
        Queue.print();
        cout << "\nNew top element: " << Queue.peek();
        
        cout << "\n\ndequeueping all remaining elements:";
        while(!Queue.isEmpty())
        {
            cout << "\ndequeueped: " << Queue.peek();
            Queue.dequeue();
        }
        
        cout << "\nQueue is now empty: " << (Queue.isEmpty() ? "Yes" : "No");
        Queue.print();
    }
    else if constexpr (std::is_same_v<T, std::string>)
    {
        Queue<std::string> Queue;
        
        cout << "\n=== Testing String Queue ===";
        cout << "\nenqueueing elements: \"Hello\", \"World\", \"Queue\", \"Test\"";
        Queue.enqueue("Hello");
        Queue.enqueue("World");
        Queue.enqueue("Queue");
        Queue.enqueue("Test");
        
        cout << "\nQueue contents:";
        Queue.print();
        
        cout << "\nQueue size: " << Queue.size();
        cout << "\nTop element (peek): " << Queue.peek();
        
        cout << "\n\ndequeueping two elements:";
        cout << "\ndequeueped: " << Queue.peek();
        Queue.dequeue();
        cout << "\ndequeueped: " << Queue.peek();
        Queue.dequeue();
        
        cout << "\nRemaining Queue:";
        Queue.print();
    }
    else if constexpr (std::is_same_v<T, char>)
    {
        Queue<char> Queue;
        
        cout << "\n=== Testing Character Queue ===";
        cout << "\nenqueueing elements: 'A', 'B', 'C', 'D'";
        Queue.enqueue('A');
        Queue.enqueue('B');
        Queue.enqueue('C');
        Queue.enqueue('D');
        
        cout << "\nQueue contents:";
        Queue.print();
        
        cout << "\nQueue size: " << Queue.size();
        cout << "\nTop element (peek): " << Queue.peek();
        
        cout << "\n\nTesting Queue reversal:";
        cout << "\ndequeueping all elements: ";
        while(!Queue.isEmpty())
        {
            cout << Queue.peek() << " ";
            Queue.dequeue();
        }
        cout << "\n";
        
        cout << "\nQueue is now empty: " << (Queue.isEmpty() ? "Yes" : "No");
    }
}
// ‚ñ≤‚ñ≤‚ñ≤ End of testQueueOperations ‚ñ≤‚ñ≤‚ñ≤


/* ======================= End of File =================== */
```

---

## üöÄ Usage Examples

### Basic Queue Operations

```cpp
// Create a queue for integers
Queue<int> myQueue;

// Enqueue elements (add to rear)
myQueue.enqueue(10);
myQueue.enqueue(20);
myQueue.enqueue(30);

// Peek at front element
int front = myQueue.peek();  // Returns 10

// Dequeue elements (remove from front)
int removed = myQueue.dequeue(); // Returns 10
```

### Advanced Operations

```cpp
// Create queue for strings
Queue<std::string> stringQueue;

// Add multiple elements
stringQueue.enqueue("First");
stringQueue.enqueue("Second");
stringQueue.enqueue("Third");

// Check queue status
if (!stringQueue.isEmpty()) {
    cout << "Queue size: " << stringQueue.size() << endl;
    stringQueue.print();
}

// Process all elements
while (!stringQueue.isEmpty()) {
    cout << "Processing: " << stringQueue.peek() << endl;
    stringQueue.dequeue();
}
```

---

## üîÑ FIFO Behavior Demonstration

### Enqueue Operations (Adding to Rear)

```
Initial: []
enqueue(10): [10]
enqueue(20): [10, 20] 
enqueue(30): [10, 20, 30]
```

### Dequeue Operations (Removing from Front)

```
Current: [10, 20, 30]
dequeue(): Returns 10 ‚Üí [20, 30]
dequeue(): Returns 20 ‚Üí [30]
dequeue(): Returns 30 ‚Üí []
```

---

## üèõÔ∏è Architecture Design

### Composition Pattern

- **Delegation**: Queue delegates storage operations to `LinkedList<T>`
- **Encapsulation**: Internal linked list is hidden from users
- **Abstraction**: Provides queue-specific interface while leveraging list functionality

### Method Mapping

|Queue Method|LinkedList Method|Purpose|
|---|---|---|
|`enqueue(value)`|`insertLast(value)`|Add to rear|
|`dequeue()`|`getFirst()` + `deleteHead()`|Remove from front|
|`peek()`|`getFirst()`|View front element|
|`isEmpty()`|`isEmpty()`|Check empty status|
|`size()`|`getLength()`|Get element count|

---

## üß™ Testing Framework

### Type-Specific Testing

The implementation includes comprehensive testing for different data types:

#### Integer Queue Testing

- Enqueue sequence: 10, 20, 30, 40
- Tests peek, dequeue, and complete emptying
- Verifies FIFO order maintenance

#### String Queue Testing

- Enqueue sequence: "Hello", "World", "Queue", "Test"
- Tests partial dequeuing operations
- Demonstrates string handling capabilities

#### Character Queue Testing

- Enqueue sequence: 'A', 'B', 'C', 'D'
- Tests complete queue reversal
- Shows character-specific functionality

---

## üìä Performance Analysis

### Time Complexity

- **Enqueue**: O(1) - Direct insertion at tail
- **Dequeue**: O(1) - Direct removal from head
- **Peek**: O(1) - Access to head element
- **Size**: O(n) - Requires traversal of linked list
- **Print**: O(n) - Traverses all elements

### Space Complexity

- **Memory Usage**: O(n) where n is the number of elements
- **Overhead**: Additional pointer storage for linked list nodes
- **Dynamic Allocation**: Memory grows and shrinks with queue size

---

## ‚ö†Ô∏è Important Notes

### Design Considerations

- **No Exception Handling**: Returns default-constructed values on error
- **Dependencies**: Requires `GS-LList.cpp` (Generic Linked List implementation)
- **Memory Management**: Relies on LinkedList's automatic cleanup
- **Thread Safety**: Not thread-safe (single-threaded use only)

### Limitations

- **Size Calculation**: O(n) operation due to linked list traversal
- **Memory Overhead**: Each element requires additional pointer storage
- **Error Handling**: Uses console output instead of exceptions

---

## üìö References

- **Data Structure Type**: Linear, Dynamic
- **Access Pattern**: FIFO (First In, First Out)
- **Implementation Strategy**: Composition with LinkedList
- **Memory Model**: Dynamic allocation with linked nodes

---

_Tags: #DataStructures #Queue #LinkedList #Templates #FIFO #Composition

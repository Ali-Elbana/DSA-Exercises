
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=40a888f7-9e6a-4fbb-9395-2dc25d5d0d67)

---

### **Priority Queue Notes**

A Priority Queue is an abstract data type where elements are stored as **priority-data pairs**, and the order of processing elements is determined by their assigned **priority**. **Lower priority numbers typically indicate higher precedence or priority**.

[![PQueue](G:\DSA\Slides\PriorityQueue\s1.png)

[![PQueue](G:\DSA\Slides\PriorityQueue\s4.png)

**Min-Heap Based Implementation:** The provided C++ implementation uses a **min-heap**. This means that the element with the **lowest priority value is considered the highest priority** and is always at the root of the heap.

- **Storage**: Elements are stored in a **dynamic array (std::vector)**. Each element is a `std::pair<int, int>` where the first integer is the priority and the second is the data.
- **Core Property**: The min-heap property ensures that for any given node, its priority is less than or equal to the priorities of its children.
- **Helper Methods (O(1) Complexity)**:
    - `getParentIndex(index)`: Calculates the index of a node's parent.
    - `getLeftChildIndex(index)`: Calculates the index of a node's left child.
    - `getRightChildIndex(index)`: Calculates the index of a node's right child.
    - `swapElements(index1, index2)`: Exchanges two elements within the internal array.
- **Key Operations**:
    - **`enqueue(priority, data)`**: Inserts a new element into the queue.
        - The new element is added to the end of the heap and then **"bubbled up"** (swapped with its parent if its priority is higher) until the min-heap property is restored.
        - **Complexity**: **O(log n)**, due to the upward bubbling process.

[![PQueue](G:\DSA\Slides\PriorityQueue\s5.png)

[![PQueue](G:\DSA\Slides\PriorityQueue\s3.png)

- **`dequeue()`**: Removes and returns the highest priority element (the root).
        - The root element is retrieved, the last element in the heap is moved to the root position, the queue size is decremented, and the new root element is then **"bubbled down"** (swapped with its highest priority child) until the min-heap property is restored.
        - **Complexity**: **O(log n)**, due to the downward bubbling process.
        - **Error Handling**: Throws `std::runtime_error` if the queue is empty.

[![PQueue](G:\DSA\Slides\PriorityQueue\s6.png)

- **`peek()`**: Returns the highest priority element **without removing it**.
        - This simply returns the element at the root of the heap.
        - **Complexity**: **O(1)**.
        - **Error Handling**: Throws `std::runtime_error` if the queue is empty.
- **Utility Methods (O(1) Complexity)**:
    - `hasData()`: Checks if the queue contains elements.
    - `getSize()`: Returns the current number of elements.
    - `empty()`: Checks if the queue is empty.
- **Display/Visualization**:
    - `print()` and `printWithPriorities()`: Print queue elements linearly.
    - **`draw()`**: Provides a **visual tree representation** of the priority queue, displaying both data and priority values in the format `data[priority]`.

**General Priority Queue Operations & Infrastructure**:

- **Common Operations**: `enqueue`, `dequeue`, `peek`, `size`, `is empty`.
- **Possible Infrastructures**: Array, Linked List, Binary Search Tree (BS Tree), Heap. Each has different performance characteristics (complexities) for the core operations. For example, `Peek` is O(1) for all of these except an Array which is O(n), while `Dequeue` is O(1) for a Linked List but O(log n) for a Heap.

[![PQueue](G:\DSA\Slides\PriorityQueue\s2.png)

---
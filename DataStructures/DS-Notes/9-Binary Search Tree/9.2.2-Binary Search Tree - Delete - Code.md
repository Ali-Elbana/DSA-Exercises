## Overview

This implementation demonstrates a simplified Binary Search Tree deletion algorithm using **parent pointers** to eliminate the need for complex recursive parent tracking. The parent pointer approach makes node manipulation significantly easier and more intuitive.

## Key Features

- **Template-based design** - Works with any comparable data type
- **Parent pointers** - Each node maintains a reference to its parent
- **Simplified deletion** - No need to track parent nodes during traversal
- **Four deletion cases** - Handles all possible node configurations

## Deletion Algorithm Analysis

### Core Method: `deleteNode(Tdata _data)`

```cpp
void deleteNode(Tdata _data)
{
    if(root == nullptr) {
        cout << "Tree is empty! Cannot delete element " << _data << endl;
        return;
    }
    
    TreeNode<Tdata>* nodeToDelete = find(_data);
    if(nodeToDelete == nullptr) {
        return; // find method already prints "not found" message
    }
    
    deleteNodeHelper(nodeToDelete);
    cout << "Element " << _data << " deleted from the tree." << endl;
}
```

**Algorithm Steps:**

1. Check if tree is empty
2. Find the target node using existing `find()` method
3. If found, delegate to `deleteNodeHelper()`
4. Confirm deletion

### Core Helper: `deleteNodeHelper(TreeNode<Tdata>* nodeToDelete)`

This method handles the four fundamental deletion cases:

#### Case 1: Leaf Node (No Children)

```cpp
if(nodeToDelete->Left == nullptr && nodeToDelete->Right == nullptr)
{
    // Simply disconnect from parent
    if(nodeToDelete->Parent == nullptr) {
        root = nullptr;  // Deleting root
    } else if(nodeToDelete->Parent->Left == nodeToDelete) {
        nodeToDelete->Parent->Left = nullptr;  // Left child
    } else {
        nodeToDelete->Parent->Right = nullptr; // Right child
    }
    delete nodeToDelete;
}
```

#### Case 2: Only Right Child

```cpp
else if(nodeToDelete->Left == nullptr)
{
    TreeNode<Tdata>* rightChild = nodeToDelete->Right;
    
    if(nodeToDelete->Parent == nullptr) {
        root = rightChild;
        rightChild->Parent = nullptr;
    } else if(nodeToDelete->Parent->Left == nodeToDelete) {
        nodeToDelete->Parent->Left = rightChild;
        rightChild->Parent = nodeToDelete->Parent;
    } else {
        nodeToDelete->Parent->Right = rightChild;
        rightChild->Parent = nodeToDelete->Parent;
    }
    delete nodeToDelete;
}
```

#### Case 3: Only Left Child

```cpp
else if(nodeToDelete->Right == nullptr)
{
    TreeNode<Tdata>* leftChild = nodeToDelete->Left;
    
    // Similar logic to Case 2, but with left child
    if(nodeToDelete->Parent == nullptr) {
        root = leftChild;
        leftChild->Parent = nullptr;
    } else if(nodeToDelete->Parent->Left == nodeToDelete) {
        nodeToDelete->Parent->Left = leftChild;
        leftChild->Parent = nodeToDelete->Parent;
    } else {
        nodeToDelete->Parent->Right = leftChild;
        leftChild->Parent = nodeToDelete->Parent;
    }
    delete nodeToDelete;
}
```

#### Case 4: Two Children (Most Complex)

```cpp
else
{
    // Find inorder successor (smallest in right subtree)
    TreeNode<Tdata>* successor = findMin(nodeToDelete->Right);
    
    // Copy successor's data to current node
    nodeToDelete->Data = successor->Data;
    
    // Recursively delete successor (will be Case 1 or 2)
    deleteNodeHelper(successor);
}
```

## Algorithm Advantages

### 1. **Parent Pointer Benefits**

- **Simplified Logic**: No need to track parent during traversal
- **Direct Manipulation**: Can directly modify parent's child pointers
- **Cleaner Code**: Eliminates complex recursive parent passing

### 2. **Recursive Elegance**

- **Case 4 Simplification**: Two-children case reduces to simpler cases
- **Guaranteed Termination**: Successor deletion is always Case 1 or 2
- **BST Property Preservation**: Inorder successor maintains tree ordering

## Time & Space Complexity

|Operation|Time Complexity|Space Complexity|
|---|---|---|
|Find Node|O(log n) avg, O(n) worst|O(1)|
|Delete Case 1-3|O(1)|O(1)|
|Delete Case 4|O(log n) avg, O(n) worst|O(log n) avg, O(n) worst|
|**Overall Deletion**|**O(log n) avg, O(n) worst**|**O(log n) avg, O(n) worst**|

## Supporting Methods

### `findMin(TreeNode<Tdata>* node)`

```cpp
TreeNode<Tdata>* findMin(TreeNode<Tdata>* node)
{
    while(node != nullptr && node->Left != nullptr) {
        node = node->Left;
    }
    return node;
}
```

- **Purpose**: Find inorder successor for Case 4
- **Complexity**: O(log n) average, O(n) worst case

### `find(const Tdata& _data)`

- **Purpose**: Locate node to delete
- **Returns**: Pointer to node or nullptr
- **Side Effect**: Prints search result message

## Node Structure Enhancement

```cpp
template<typename Tdata>
class TreeNode
{
public:
    Tdata Data;
    TreeNode<Tdata>* Left;
    TreeNode<Tdata>* Right;
    TreeNode<Tdata>* Parent;  // Key addition for simplified deletion
    
    TreeNode(Tdata _data) : Data(_data), Left(nullptr), Right(nullptr), Parent(nullptr) {}
};
```

The **Parent pointer** is the critical enhancement that enables this simplified deletion approach.

## Usage Example

```cpp
BinaryTree<int> tree;
tree.Insert(4);
tree.Insert(2);
tree.Insert(6);
tree.Insert(1);
tree.Insert(3);

tree.deleteNode(2);  // Case 4: Two children
tree.deleteNode(1);  // Case 1: Leaf node
tree.deleteNode(6);  // Case 1: Leaf node (after tree restructuring)
```

## Implementation Notes

### Memory Management

- **Proper Cleanup**: All cases properly `delete` the target node
- **Pointer Updates**: Parent pointers maintained correctly after deletion
- **No Memory Leaks**: Single responsibility - each node deleted exactly once

### BST Property Preservation

- **Inorder Successor**: Guarantees BST ordering is maintained
- **Structural Integrity**: Parent-child relationships remain consistent
- **Search Efficiency**: Tree remains searchable after any deletion

## Alternative Approaches

### Without Parent Pointers

Traditional BST deletion requires:

- **Parent Tracking**: Pass parent reference through recursion
- **Complex Logic**: Determine if node is left or right child
- **More Parameters**: Additional function signatures

### With Parent Pointers (This Implementation)

- **Direct Access**: Immediate parent reference available
- **Simplified Cases**: Cleaner conditional logic
- **Easier Maintenance**: More readable and debuggable code

---

## Tags

`#data-structures` `#binary-search-tree` `#algorithms` `#cpp` `#deletion` `#parent-pointers` `#templates`

## Complete Code Implementation

### BSTree.cpp

```cpp
/*
============================================================
* Project: Binary Search Tree Implementation with Parent Pointers
* File:    BSTree.cpp
* Author:  [Ali El-bana]
* Date:    [2025-08-25]
* Version: v2.0
------------------------------------------------------------
* Description:
* Template-based binary search tree implementation with parent pointers
* for simplified deletion and enhanced tree operations
------------------------------------------------------------
* Notes:
* - Uses parent pointers for easier tree manipulation
* - Simple recursive deletion algorithm
* - Template class supports any comparable data type
============================================================
*/

/* ====================== Includes ====================== */
#include <iostream>
#include <queue>
#include <vector>
#include <string>
#include <iomanip>
#include <cmath>

/* =================== Namespace Usage ================== */
using std::cout;
using std::endl;
using std::queue;
using std::vector;
using std::string;
using std::setw;
using std::setfill;

/* ====================== Declarations ================== */
template <typename Tdata>
class TreeNode;

template <typename Tdata>
class BinaryTree;

/* ===================== Class Definitions =============== */
template<typename Tdata>
class TreeNode
{
public:
	Tdata Data;
	TreeNode<Tdata> * Left;
	TreeNode<Tdata> * Right;
	TreeNode<Tdata> * Parent;  // Parent pointer for easier manipulation
	
	// Constructor
	TreeNode(Tdata _data) : Data(_data), Left(nullptr), Right(nullptr), Parent(nullptr) {}
};

template<typename Tdata>
class BinaryTree
{
private:
	TreeNode<Tdata> * root;
	
	// Private Helper Methods
    void destroyTree(TreeNode<Tdata>* node);
    int getHeight(TreeNode<Tdata>* node);
    void printTree(TreeNode<Tdata>* node, string prefix, bool isLast);
	void preOrderHelper(TreeNode<Tdata>* node);
    void inOrderHelper(TreeNode<Tdata>* node);
    void postOrderHelper(TreeNode<Tdata>* node);
	TreeNode<Tdata>* findHelper(TreeNode<Tdata>* node, const Tdata & _data);
    TreeNode<Tdata>* findMin(TreeNode<Tdata>* node);
    void deleteNodeHelper(TreeNode<Tdata>* nodeToDelete);
	
public:
	// Constructor and Destructor
    BinaryTree();
    ~BinaryTree();
    
    // Public Methods
    void Insert(Tdata _data);
    void Print();
	void preOrder();
    void inOrder();
    void postOrder();
	TreeNode<Tdata>* find(const Tdata & _data);
    void deleteNode(Tdata _data);
};

/* ================== Method Definitions =============== */
template<typename Tdata>
BinaryTree<Tdata>::BinaryTree()
{
	root = nullptr;
}

template<typename Tdata>
BinaryTree<Tdata>::~BinaryTree()
{
	destroyTree(root);
}

template <typename Tdata>
void BinaryTree<Tdata>::destroyTree(TreeNode<Tdata>* node) 
{
    if(node != nullptr) 
	{
        destroyTree(node->Left);
        destroyTree(node->Right);
        delete node;
    }
}

template <typename Tdata>
void BinaryTree<Tdata>::Insert(Tdata _data) 
{
	TreeNode<Tdata> * newNode = new TreeNode<Tdata>(_data);
	
	if(root == nullptr)
	{
		root = newNode;
		return;
	}
	else
	{
		TreeNode<Tdata> * currNode = root;
		TreeNode<Tdata> * parentNode = nullptr;
		
		while(currNode != nullptr)
		{
			parentNode = currNode;  // Keep track of parent
			
			if(_data < currNode->Data)
			{
				currNode = currNode->Left;
			}
			else // if(_data >= currNode->data)
			{
				currNode = currNode->Right;
			}
		}
		
		// Set parent for new node
		newNode->Parent = parentNode;
		
		// Insert as left or right child
		if(_data < parentNode->Data)
		{
			parentNode->Left = newNode;
		}
		else
		{
			parentNode->Right = newNode;
		}
	}
}

template <typename Tdata>
int BinaryTree<Tdata>::getHeight(TreeNode<Tdata>* node) 
{
    if(node == nullptr) 
	{
        return 0;
    }
    
    int leftHeight = getHeight(node->Left);
    int rightHeight = getHeight(node->Right);
    
    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
}

template <typename Tdata>
void BinaryTree<Tdata>::printTree(TreeNode<Tdata>* node, string prefix, bool isLast) 
{
    if(node != nullptr) 
    {
        cout << prefix;
        cout << (isLast ? "|____ " : "|---- ");
        cout << node->Data << endl;

        // Count children
        bool hasLeft = (node->Left != nullptr);
        bool hasRight = (node->Right != nullptr);

        if(hasLeft == true || hasRight == true) 
        {
            // Print RIGHT child first (so it appears on the right side visually)
            if(hasRight == true) 
            {
                printTree(node->Right, prefix + (isLast ? "    " : "|   "), !hasLeft);
            }
            // Then print LEFT child
            if(hasLeft == true) 
            {
                printTree(node->Left, prefix + (isLast ? "    " : "|   "), true);
            }
        }
    }
}

template <typename Tdata>
void BinaryTree<Tdata>::Print() 
{
    if (root == nullptr) {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\n" << string(50, '=') << endl;
    cout << "         BINARY TREE VISUALIZATION" << endl;
    cout << string(50, '=') << endl << endl;
    
    printTree(root, "", false);
    
    cout << endl << string(50, '=') << endl << endl;
}

template <typename Tdata>
void BinaryTree<Tdata>::preOrderHelper(TreeNode<Tdata>* node)
{
    if(node != nullptr)
    {
        cout << node->Data << " ";
        preOrderHelper(node->Left);
        preOrderHelper(node->Right);
    }
}

template <typename Tdata>
void BinaryTree<Tdata>::preOrder()
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\nPre-Order Traversal (Root -> Left -> Right): ";
    preOrderHelper(root);
    cout << endl;
}

template <typename Tdata>
void BinaryTree<Tdata>::inOrderHelper(TreeNode<Tdata>* node)
{
    if(node != nullptr)
    {
        inOrderHelper(node->Left);
        cout << node->Data << " ";
        inOrderHelper(node->Right);
    }
}

template <typename Tdata>
void BinaryTree<Tdata>::inOrder()
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\nIn-Order Traversal (Left -> Root -> Right): ";
    inOrderHelper(root);
    cout << endl;
}

template <typename Tdata>
void BinaryTree<Tdata>::postOrderHelper(TreeNode<Tdata>* node)
{
    if(node != nullptr)
    {
        postOrderHelper(node->Left);
        postOrderHelper(node->Right);
        cout << node->Data << " ";
    }
}

template <typename Tdata>
void BinaryTree<Tdata>::postOrder()
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return;
    }
    
    cout << "\nPost-Order Traversal (Left -> Right -> Root): ";
    postOrderHelper(root);
    cout << endl;
}

template <typename Tdata>
TreeNode<Tdata>* BinaryTree<Tdata>::findHelper(TreeNode<Tdata>* node, const Tdata& _data)
{
    if(node == nullptr)
    {
        return nullptr; // not found
    }

    if(node->Data == _data)
    {
        return node; // found
    }

    if(_data < node->Data)
    {
        return findHelper(node->Left, _data);
    }
    else
    {
        return findHelper(node->Right, _data);
    }
}

template <typename Tdata>
TreeNode<Tdata>* BinaryTree<Tdata>::find(const Tdata& _data)
{
    if(root == nullptr)
    {
        cout << "Tree is empty!" << endl;
        return nullptr;
    }

    TreeNode<Tdata>* result = findHelper(root, _data);

    if(result != nullptr)
    {
        cout << "Element " << _data << " found in the tree." << endl;
    }
    else
    {
        cout << "Element " << _data << " not found in the tree." << endl;
    }

    return result;
}

template <typename Tdata>
TreeNode<Tdata>* BinaryTree<Tdata>::findMin(TreeNode<Tdata>* node)
{
    while(node != nullptr && node->Left != nullptr)
    {
        node = node->Left;
    }
    return node;
}

template <typename Tdata>
void BinaryTree<Tdata>::deleteNodeHelper(TreeNode<Tdata>* nodeToDelete)
{
    if(nodeToDelete == nullptr)
    {
        return;
    }
    
    // Case 1: Node has no children (leaf node)
    if(nodeToDelete->Left == nullptr && nodeToDelete->Right == nullptr)
    {
        if(nodeToDelete->Parent == nullptr)
        {
            root = nullptr;
        }
        else if(nodeToDelete->Parent->Left == nodeToDelete)
        {
            nodeToDelete->Parent->Left = nullptr;
        }
        else
        {
            nodeToDelete->Parent->Right = nullptr;
        }
        
        delete nodeToDelete;
    }
    
    // Case 2: Node has only right child
    else if(nodeToDelete->Left == nullptr)
    {
        TreeNode<Tdata>* rightChild = nodeToDelete->Right;
        
        if(nodeToDelete->Parent == nullptr)
        {
            root = rightChild;
            rightChild->Parent = nullptr;
        }
        else if(nodeToDelete->Parent->Left == nodeToDelete)
        {
            nodeToDelete->Parent->Left = rightChild;
            rightChild->Parent = nodeToDelete->Parent;
        }
        else
        {
            nodeToDelete->Parent->Right = rightChild;
            rightChild->Parent = nodeToDelete->Parent;
        }
        
        delete nodeToDelete;
    }
    
    // Case 3: Node has only left child
    else if(nodeToDelete->Right == nullptr)
    {
        TreeNode<Tdata>* leftChild = nodeToDelete->Left;
        
        if(nodeToDelete->Parent == nullptr)
        {
            root = leftChild;
            leftChild->Parent = nullptr;
        }
        else if(nodeToDelete->Parent->Left == nodeToDelete)
        {
            nodeToDelete->Parent->Left = leftChild;
            leftChild->Parent = nodeToDelete->Parent;
        }
        else
        {
            nodeToDelete->Parent->Right = leftChild;
            leftChild->Parent = nodeToDelete->Parent;
        }
        
        delete nodeToDelete;
    }
    
    // Case 4: Node has both children
    else
    {
        TreeNode<Tdata>* successor = findMin(nodeToDelete->Right);
        nodeToDelete->Data = successor->Data;
        deleteNodeHelper(successor);
    }
}

template <typename Tdata>
void BinaryTree<Tdata>::deleteNode(Tdata _data)
{
    if(root == nullptr)
    {
        cout << "Tree is empty! Cannot delete element " << _data << endl;
        return;
    }
    
    TreeNode<Tdata>* nodeToDelete = find(_data);
    if(nodeToDelete == nullptr)
    {
        return;
    }
    
    deleteNodeHelper(nodeToDelete);
    cout << "Element " << _data << " deleted from the tree." << endl;
}
```

### main.cpp

```cpp
/*
============================================================
* Project: Binary Search Tree Implementation
* File:    main.cpp  
* Author:  [Ali El-bana]
* Date:    [2025-08-24]
* Version: v1.0
------------------------------------------------------------
* Description:
* Main application to demonstrate binary search tree functionality
* with visual tree representation
============================================================
*/

#include "BSTree.cpp"
#include <iostream>

using std::cout;
using std::endl;

int main()
{
    system("cls"); // Clear console (Windows)
    cout << "Binary Search Tree Demonstration Program" << endl;
    cout << "=================================" << endl;

    BinaryTree<int> tree_int;

    cout << "\nInserting elements: 4, 2, 1, 3, 5, 6" << endl;

    tree_int.Insert(4);
    tree_int.Insert(2);
    tree_int.Insert(1);
    tree_int.Insert(3);
    tree_int.Insert(5);
    tree_int.Insert(6);

    cout << "\nTree structure:" << endl;
    tree_int.Print();

    // Find operations
    tree_int.find(3);
    tree_int.find(7);

    // Delete operations with tree visualization
    tree_int.deleteNode(7);  // Not found case
    tree_int.deleteNode(4);  // Root deletion (Case 4)
    cout << "\nTree structure after deleting 4:" << endl;
    tree_int.Print();
    
    tree_int.deleteNode(2);  // Case 4 - two children
    cout << "\nTree structure after deleting 2:" << endl;
    tree_int.Print();
    
    tree_int.deleteNode(1);  // Case 1 - leaf node
    cout << "\nTree structure after deleting 1:" << endl;
    tree_int.Print();
    
    tree_int.deleteNode(5);  // Case 2 - only right child
    cout << "\nTree structure after deleting 5:" << endl;
    tree_int.Print();
    
    tree_int.deleteNode(3);  // Case 1 - leaf node
    cout << "\nTree structure after deleting 3:" << endl;
    tree_int.Print();
    
    tree_int.deleteNode(6);  // Last node (root)
    cout << "\nTree structure after deleting 6:" << endl;
    tree_int.Print();

    cout << "Program completed successfully!" << endl;
    return 0;
}
```


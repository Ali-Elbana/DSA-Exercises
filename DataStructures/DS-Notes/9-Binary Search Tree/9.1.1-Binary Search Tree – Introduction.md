
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=14da8f39-e2f5-466d-9a52-7f4148ab8993)

---
This document describes a **C++ template-based binary search tree implementation**, authored by Ali El-bana, version v1.0, dated 2025-08-24. The project aims to provide a robust implementation with **level-order insertion, find, and visual tree printing functionality**. It is designed to demonstrate binary search tree functionality with visual tree representation.

**The code reference:** [[9.1.2-Binary Search Tree â€“ Code#Complete Code Implementation]]

---
### Binary Search Tree (BST) Overview

- A Binary Search Tree is a data structure designed for **faster search operations**.
- **Properties**:
    - The **left node** is always **less than its parent**.
    - The **right node** is always **greater than its parent**.
- The implementation uses a **template class** to support any comparable data type.

[![BST](G:\DSA\Slides\BST-Intro\s2.png)

---
### Core Components

1. **`TreeNode` Class**:
    
    - Stores the `Data` of the node (of type `Tdata`).
    - Contains pointers to the `Left` child (`TreeNode<Tdata> * Left`) and `Right` child (`TreeNode<Tdata> * Right`).
    - The constructor initializes `Data` with a given value and sets `Left` and `Right` pointers to `nullptr`.
2. **`BinaryTree` Class**:
    
    - Manages the `root` node of the tree (`TreeNode<Tdata> * root`).
    - **Private Helper Methods**:
        - `destroyTree(TreeNode<Tdata>* node)`: Recursively deallocates memory for the tree.
        - `getHeight(TreeNode<Tdata>* node)`: Calculates the height of a subtree.
        - `printTree(TreeNode<Tdata>* node, string prefix, bool isLast)`: Facilitates visual console output of the tree structure.
        - `preOrderHelper`, `inOrderHelper`, `postOrderHelper`: Recursive helpers for tree traversals.
        - `findHelper(TreeNode<Tdata>* node, const Tdata & _data)`: Recursively searches for a node.
        - `findDeepestRightmost(TreeNode<Tdata>* node)`: Finds the deepest rightmost node in a given subtree using level-order traversal.
        - `deleteNodeHelper(TreeNode<Tdata>*& root, Tdata _data)`: Handles the logic for deleting a node.
    - **Public Methods**:
        - **`BinaryTree()`**: Constructor; initializes `root` to `nullptr`.
        - **`~BinaryTree()`**: Destructor; calls `destroyTree` on the `root` to clean up memory.
        - **`Insert(Tdata _data)`**: Inserts a new element into the tree.
        - **`Print()`**: Displays a visual representation of the tree in the console.
        - **`preOrder()`**: Performs a pre-order traversal (Root -> Left -> Right).
        - **`inOrder()`**: Performs an in-order traversal (Left -> Root -> Right).
        - **`postOrder()`**: Performs a post-order traversal (Left -> Right -> Root).
        - **`find(const Tdata & _data)`**: Searches for a specific element in the tree.
        - **`deleteNode(Tdata _data)`**: Deletes a specified element from the tree.

---
### Detailed Functionality

- **`Insert` Method**:
    
    - Creates a `newNode`.
    - If the tree is empty, the `newNode` becomes the `root`.
    - Otherwise, it iteratively traverses the tree, comparing the new data with current node data. If `_data` is less than `currNode->Data`, it moves to the left child; otherwise, it moves to the right child (`_data >= currNode->data`). The new node is inserted when an appropriate `nullptr` child is found.
    - This specific implementation uses a **level-order (breadth-first) insertion strategy**.
    - The typical **time complexity for insertion is O(log n)**.
    - Example insertion sequence: 4, 2, 1, 3, 5, 6.

[![BST](G:\DSA\Slides\BST-Intro\s12.png)

- **`Print` Method**:
    
    - Checks if the tree is empty.
    - Prints a banner "BINARY TREE VISUALIZATION".
    - Calls `printTree` helper, which recursively prints nodes with prefixes (`|____` or `|----`) to create a **visual tree representation in the console output**. It prints the right child before the left to display the right side visually higher.
- **`find` Method**:
    
    - Checks if the tree is empty.
    - Calls `findHelper`, which recursively searches for the `_data`.
    - If `_data` is less than the current node's data, it searches in the left subtree; otherwise, it searches in the right subtree.
    - Prints a message indicating if the element was found or not.
    - The typical **time complexity for finding an element is O(log n)**.

[![BST](G:\DSA\Slides\BST-Intro\s14.png)

---
### Duplication Handling

- The sources indicate three general methods for handling duplicates in a Binary Search Tree: **Don't Allow duplication, Allow duplication, or Add Counter**.
- Based on the `Insert` method's `else` condition (`_data >= currNode->data`), this specific C++ implementation **allows duplication** by placing elements greater than or equal to the current node's data into the right subtree.

[![BST](G:\DSA\Slides\BST-Intro\s3.png)

---
### Main Application Demonstration

The `main.cpp` file demonstrates the functionality:

- It initializes a `BinaryTree` for integers (`BinaryTree<int> tree_int`).
- **Inserts** the elements: 4, 2, 1, 3, 5, 6.
- **Prints** the tree structure visually.
- Performs **find operations** for elements 3 (found) and 7 (not found).

---


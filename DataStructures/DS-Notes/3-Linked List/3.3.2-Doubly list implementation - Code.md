## Overview

A C++ implementation of a doubly linked list data structure that maintains bidirectional links between nodes. This enhanced version provides more efficient operations compared to singly linked lists, particularly for deletion and bidirectional traversal.

**Author**: Ali El-bana  
**Date**: 2025-08-13  
**Version**: v1.0  
**Purpose**: Educational implementation of doubly linked list with comprehensive operations

## Doubly Linked List Advantages

- ✅ **Bidirectional Traversal**: Can move forward and backward through the list
- ✅ **Efficient Deletion**: O(1) deletion when node pointer is known
- ✅ **Previous Node Access**: Direct access to previous node without traversal
- ✅ **Enhanced Operations**: Improved insertion and deletion algorithms

## Data Structure Characteristics

- **Type**: Dynamic bidirectional linear data structure
- **Memory**: Non-contiguous allocation with dual pointers
- **Access**: Sequential (O(n) time complexity)
- **Space Overhead**: Additional memory for prev pointers
- **Flexibility**: Supports operations from both ends efficiently

## Class Architecture

### Enhanced Node Class

```cpp
class Node {
public:
    int data;        // Data storage
    Node * next;     // Forward link
    Node * prev;     // Backward link (NEW!)
    
    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};
```

**Key Enhancement**: Addition of `prev` pointer enables bidirectional navigation

**Memory Layout**:

```
[prev|data|next] <-> [prev|data|next] <-> [prev|data|next]
```

### LinkedList Class Structure

```cpp
class LinkedList {
private:
    Node * head;    // First node
    Node * tail;    // Last node
    size_t length;  // Node count
    
public:
    // Constructor, destructor, and 8 methods
};
```

## Core Operations Analysis

### Basic List Building

#### `insertLast(int val)` - Enhanced with Bidirectional Links

```cpp
void insertLast(int val) {
    Node * newNode = new Node(val);
    
    if(head == nullptr) {
        // Empty list case
        head = newNode;
        tail = newNode;
    }
    else {
        // Link establishment
        tail->next = newNode;     // Forward link
        newNode->prev = tail;     // Backward link (NEW!)
        newNode->next = nullptr;  // Terminate forward
        tail = newNode;           // Update tail
    }
    length++;
}
```

**Bidirectional Link Pattern**:

```
Before: [A] <-> [B] <-> [C]
After:  [A] <-> [B] <-> [C] <-> [NEW]
```

### Advanced Insertion Operations

#### `insertAfter(size_t idx, int newData)` - Doubly Linked Version

```cpp
void inserAfter(size_t idx, int newData) {
    Node * currNode = getNodeAt(idx);
    Node * newNode = new Node(newData);
    
    // Four-way linking
    newNode->prev = currNode;           // 1. Back to current
    newNode->next = currNode->next;     // 2. Forward to next
    currNode->next = newNode;           // 3. Current forward
    
    if(currNode == tail) {
        tail = newNode;                 // Tail update
    }
    else {
        newNode->next->prev = newNode;  // 4. Next back to new
    }
    length++;
}
```

**Four-Way Link Update**:

```
Before: [A] <-> [B] <-> [C]
Insert X after B:
Step 1: newNode->prev = B
Step 2: newNode->next = C
Step 3: B->next = newNode
Step 4: C->prev = newNode
Result: [A] <-> [B] <-> [X] <-> [C]
```

#### `insertBefore(size_t idx, int newData)` - Optimized Doubly Linked

```cpp
void insertBefore(size_t idx, int newData) {
    if(idx == 0) {
        // Head insertion
        Node * newNode = new Node(newData);
        newNode->prev = nullptr;
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
    else {
        // General case - direct approach
        Node * currNode = getNodeAt(idx);
        Node * newNode = new Node(newData);
        
        newNode->next = currNode;
        newNode->prev = currNode->prev;
        currNode->prev = newNode;
        newNode->prev->next = newNode;
    }
    length++;
}
```

**Advantage**: No need to find previous node - direct access via `currNode->prev`

### Enhanced Deletion Operations

#### `deleteNode(size_t idx)` - Simplified with Bidirectional Links

```cpp
void deleteNode(size_t idx) {
    if(idx == 0 && length == 1) {
        // Single node
        Node * currNode = getNodeAt(idx);
        head = nullptr;
        tail = nullptr;
        delete currNode;
    }
    else if(idx == 0) {
        // Delete head
        Node * currNode = head;
        currNode->next->prev = nullptr;  // Next node's prev = null
        head = currNode->next;
        delete currNode;
    }
    else if(idx == (length - 1)) {
        // Delete tail
        Node * currNode = tail;
        currNode->prev->next = nullptr;  // Previous node's next = null
        tail = currNode->prev;
        delete currNode;
    }
    else {
        // Delete middle - elegant solution
        Node * currNode = getNodeAt(idx);
        currNode->prev->next = currNode->next;  // Bypass forward
        currNode->next->prev = currNode->prev;  // Bypass backward
        delete currNode;
    }
    length--;
}
```

**Key Advantage**: Middle deletion requires only the current node - no separate previous node lookup needed!

## Performance Comparison: Single vs Double Linked Lists

|Operation|Singly Linked|Doubly Linked|Improvement|
|---|---|---|---|
|`insertAfter()`|O(n)|O(n)|Same|
|`insertBefore()`|O(n)|O(n)|Cleaner code|
|`deleteNode()` middle|O(n) + O(n)|O(n)|Better algorithm|
|Backward traversal|Not possible|O(n)|New capability|
|Delete with node pointer|O(n)|O(1)|Major improvement|

### Space vs Time Tradeoff

- **Extra Memory**: ~33% more (additional prev pointer per node)
- **Time Savings**: Simplified algorithms and potential O(1) operations
- **Code Clarity**: More intuitive bidirectional operations

## Memory Management Strategy

### Enhanced Linking Pattern

```cpp
// Single Link: A -> B -> C
// Double Link: A <-> B <-> C
//              ↑          ↑
//            head       tail
```

### Pointer Safety in Doubly Linked Lists

- **Four-Way Consistency**: Every operation must maintain forward and backward links
- **Null Termination**: First node's prev = nullptr, last node's next = nullptr
- **Link Integrity**: Any broken link corrupts bidirectional navigation

## Sample Execution Analysis

### Build Phase

```cpp
list.insertLast(10);     // [10]
list.insertLast(20);     // [10] <-> [20]
list.insertLast(30);     // [10] <-> [20] <-> [30]
list.insertLast(40);     // [10] <-> [20] <-> [30] <-> [40]
```

### Advanced Operations

```cpp
list.inserAfter(1, 25);           // [10] <-> [20] <-> [25] <-> [30] <-> [40]
list.inserAfter(length-1, 45);    // [10] <-> [20] <-> [25] <-> [30] <-> [40] <-> [45]
list.insertBefore(4, 35);         // [10] <-> [20] <-> [25] <-> [30] <-> [35] <-> [40] <-> [45]
```

### Deletion Sequence

```cpp
list.deleteNode(0);       // Delete head: [20] <-> [25] <-> [30] <-> [35] <-> [40] <-> [45]
list.deleteNode(length-1); // Delete tail: [20] <-> [25] <-> [30] <-> [35] <-> [40]
list.deleteNode(1);       // Delete middle: [20] <-> [30] <-> [35] <-> [40]
```

## Algorithm Complexity Analysis

### Time Complexity

|Method|Best Case|Average Case|Worst Case|Notes|
|---|---|---|---|---|
|`getNodeAt()`|O(1)|O(n/2)|O(n)|Could optimize with bidirectional search|
|`insertLast()`|O(1)|O(1)|O(1)|Tail pointer optimization|
|`insertAfter()`|O(1)|O(n/2)|O(n)|Traversal + O(1) insertion|
|`insertBefore()`|O(1)|O(n/2)|O(n)|Direct prev access|
|`deleteNode()`|O(1)|O(n/2)|O(n)|Simplified deletion logic|

### Space Complexity

- **Node Storage**: O(n) where n = number of nodes
- **Extra Pointers**: +50% memory overhead for prev pointers
- **Total**: O(1.5n) compared to singly linked list

## Potential Optimizations

### Bidirectional Search Enhancement

```cpp
Node * getNodeAtOptimized(size_t idx) {
    if(idx < length/2) {
        // Search from head
        Node * curr = head;
        for(size_t i = 0; i < idx; i++) {
            curr = curr->next;
        }
        return curr;
    }
    else {
        // Search from tail (NEW CAPABILITY!)
        Node * curr = tail;
        for(size_t i = length-1; i > idx; i--) {
            curr = curr->prev;
        }
        return curr;
    }
}
```

**Performance Improvement**: Reduces average traversal time from O(n/2) to O(n/4)

## Complete Code Implementation

```cpp
/*
============================================================
* Project: [Double Linked List Implementation]
* File:    [DLinkedList.cpp]
* Author:  [Ali El-bana]
* Date:    [2025-08-13]
* Version: [v1.0]
------------------------------------------------------------
* Description:
* [Self implementation of a double linked list]
------------------------------------------------------------
* Notes:
* [This is for an educational purpose]
============================================================
*/

#include <iostream>
#include <string>

using std::cout;
using std::cin;
using std::cerr;
using std::endl;

class Node {
public:
    int data;
    Node * next;
    Node * prev;
    
    Node(int val) : data(val), next(nullptr), prev(nullptr){}
};

class LinkedList {
private:
    Node * head;
    Node * tail;
    size_t length;
    
public:
    LinkedList(): head(nullptr), tail(nullptr), length(0){}
    
    ~LinkedList() {
        while(head != nullptr) {
            Node * tmp = head;
            head = tmp->next;
            delete tmp;
        }
    }
    
    int getDataAt(size_t idx) {
        Node * currNode = head;
        
        if(idx >= length) {
            cout << "\nIndex out of range.";
        }
        else {
            size_t i{0};
            while(i != idx) {
                currNode = currNode->next;
                i++;
            }
        }
        return currNode->data;
    }
    
    Node * getNodeAt(size_t idx) {
        Node * currNode = head;
        
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else {
            size_t i{0};
            while(i < idx) {
                currNode = currNode->next;
                i++;
            }
        }
        return currNode;
    }
    
    void insertLast(int val) {
        Node * newNode = new Node(val);
        
        if(head == nullptr) {
            head = newNode;
            tail = newNode;
        }
        else {
            tail->next = newNode;
            newNode->prev = tail;
            newNode->next = nullptr;
            tail = newNode;
        }
        length++; 
    }
    
    void inserAfter(size_t idx, int newData) {
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else {
            Node * currNode = getNodeAt(idx);
            Node * newNode = new Node(newData);
            
            newNode->prev = currNode;
            newNode->next = currNode->next;
            currNode->next = newNode;
            
            if(currNode == tail) {
                tail = newNode;
            }
            else {
                newNode->next->prev = newNode;
            }
            length++; 
        }
    }
    
    void insertBefore(size_t idx, int newData) {
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else if(idx == 0) {
            Node * currNode = head;
            Node * newNode = new Node(newData);
            
            newNode->prev = nullptr;
            newNode->next = currNode;
            currNode->prev = newNode;
            head = newNode;
            length++; 
        }
        else {
            Node * currNode = getNodeAt(idx); 
            Node * newNode = new Node(newData);
            
            newNode->next = currNode;
            newNode->prev = currNode->prev;
            currNode->prev = newNode;
            newNode->prev->next = newNode;
            length++; 
        }
    }
    
    void deleteNode(size_t idx) {
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else if(idx == 0 && length == 1) {
            Node * currNode = getNodeAt(idx);
            head = nullptr;
            tail = nullptr;
            delete currNode;
            length--;
        }
        else if(idx == 0) {
            Node * currNode = head;
            currNode->next->prev = nullptr;
            head = currNode->next;
            delete currNode; 
            length--; 
        }
        else if(idx == (length - 1)) {
            Node * currNode = tail;
            currNode->prev->next = nullptr;
            tail = currNode->prev;
            delete currNode;
            length--; 
        }
        else {
            Node * currNode = getNodeAt(idx);
            currNode->prev->next = currNode->next;
            currNode->next->prev = currNode->prev;
            delete currNode;
            length--; 
        }
    }
    
    void printList() {
        Node * currNode = head;
        
        cout << '\n';
        while(currNode != nullptr) {
            cout << currNode->data << " --> ";
            currNode = currNode->next;
        }
        cout << "NULL\n";
    }
    
    size_t getLength(void) {
        return length;
    }
};

int main(void) {
    system("cls");
    cout << "\nProgram started...\n";
    LinkedList list;
    
    list.insertLast(10);
    list.insertLast(20);
    list.insertLast(30);
    list.insertLast(40);
    
    list.inserAfter(1, 25);
    
    size_t length = list.getLength();
    list.inserAfter(length - 1, 45);
    
    list.insertBefore(4, 35);
    list.printList();
    
    cout << "\nDelete the head of the list:";
    list.deleteNode(0);
    list.printList();
    
    length = list.getLength();
    
    cout << "\nDelete the tail of the list:";
    list.deleteNode(length - 1);
    list.printList();
    
    cout << "\nDelete a node from the list:";
    list.deleteNode(1);
    list.printList();
    
    int data = list.getDataAt(1);
    cout << "\nThe Node at index " << 1 << " its data = " << data;
    cout << "\nThe linked list length = " << list.getLength() << '\n';
    
    return 0;
}
```

## Key Implementation Insights

### Bidirectional Link Management

Every insertion/deletion operation must maintain **four-way consistency**:

1. **Forward Links**: Maintain next pointer chain
2. **Backward Links**: Maintain prev pointer chain
3. **Head/Tail Updates**: Update boundary pointers when needed
4. **Null Terminations**: Ensure proper list termination

### Algorithm Improvements Over Singly Linked Lists

- **Direct Previous Access**: `currNode->prev` eliminates need for separate traversal
- **Simplified Deletion**: Middle node deletion becomes more elegant
- **Better Insertion Logic**: `insertBefore()` has cleaner implementation
- **Future Optimization Potential**: Bidirectional search can halve average traversal time

## Future Enhancements

- [ ] **Bidirectional Iterator**: Enable range-based for loops
- [ ] **Optimized Search**: Implement bidirectional `getNodeAt()`
- [ ] **Reverse Printing**: Add `printListReverse()` method
- [ ] **Template Support**: Generic data type implementation
- [ ] **Circular Variant**: Connect tail->next to head
- [ ] **STL Compatibility**: Implement standard container interface

## Related Concepts

- [[Bidirectional Data Structures]]
- [[Memory Layout Optimization]]
- [[Pointer Network Management]]
- [[Algorithm Space-Time Tradeoffs]]
- [[Advanced Linked List Variants]]

---

**Tags**: #cpp #datastructures #doublylinkedlist #bidirectional #pointers #algorithms #memory-management #educational
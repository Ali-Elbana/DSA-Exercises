## Overview

A custom C++ implementation of a singly linked list data structure for educational purposes. This implementation provides basic functionality for creating, manipulating, and accessing elements in a linked list.

**Author**: Ali El-bana  
**Date**: 2025-08-11  
**Version**: v1.0

## Data Structure Characteristics

- **Type**: Dynamic linear data structure
- **Memory**: Non-contiguous allocation
- **Access**: Sequential (O(n) time complexity)
- **Insertion**: O(1) at tail, O(n) at arbitrary position
- **Space Complexity**: O(n) where n is the number of elements

## Class Architecture

### Node Class

```cpp
class Node {
public:
    int data;      // Stores the actual value
    Node * next;   // Pointer to the next node
    
    Node(int val) : data(val), next(nullptr) {}
};
```

**Purpose**: Represents a single element in the linked list

- **data**: Integer value stored in the node
- **next**: Pointer linking to the next node (nullptr for last node)
- **Constructor**: Initializes data and sets next to nullptr

### LinkedList Class

```cpp
class LinkedList {
private:
    Node * head;    // Points to first node
    Node * tail;    // Points to last node  
    size_t length;  // Tracks number of elements
    
public:
    // Constructor, destructor, and methods...
};
```

**Purpose**: Manages the entire linked list structure

- **head**: Pointer to the first node (nullptr if empty)
- **tail**: Pointer to the last node (optimization for O(1) insertion)
- **length**: Maintains count of nodes for efficient size queries

## Core Methods

### Constructor & Destructor

```cpp
LinkedList(): head(nullptr), tail(nullptr), length(0) {}

~LinkedList() {
    while(head != nullptr) {
        Node * tmp = head;
        head = tmp->next;
        delete tmp;
    }
}
```

- **Constructor**: Initializes empty list
- **Destructor**: Prevents memory leaks by deleting all nodes

### Element Access

```cpp
int getAt(size_t idx)
```

**Functionality**: Retrieves element at specified index

- **Time Complexity**: O(n)
- **Validation**: Checks for index out of bounds
- **Traversal**: Sequential from head to target index

### Insertion

```cpp
void insertLast(int val)
```

**Functionality**: Adds new element at the end of the list

- **Time Complexity**: O(1) due to tail pointer
- **Edge Cases**: Handles empty list initialization
- **Memory Management**: Dynamically allocates new node

### Utility Methods

```cpp
void printList()        // Displays all elements
size_t getLength(void)  // Returns list size
```

## Memory Management Strategy

### Dynamic Allocation

- Each node is allocated using `new` operator
- Destructor ensures proper cleanup with `delete`
- No memory leaks when list goes out of scope

### Pointer Management

- **head**: Always points to first element
- **tail**: Maintained for efficient insertion
- **next**: Links nodes sequentially

## Implementation Details

### Edge Case Handling

1. **Empty List**:
    
    - head and tail are nullptr
    - length is 0
    - insertLast creates first node
2. **Single Element**:
    
    - head and tail point to same node
    - next pointer is nullptr
3. **Index Validation**:
    
    - getAt checks bounds before traversal
    - Prevents segmentation faults

### Performance Characteristics

|Operation|Time Complexity|Space Complexity|
|---|---|---|
|Access|O(n)|O(1)|
|Insert|O(1)*|O(1)|
|Delete|O(n)|O(1)|
|Search|O(n)|O(1)|

*At tail position only

## Sample Usage

```cpp
LinkedList list;
list.insertLast(1);
list.insertLast(2);
list.insertLast(3);
list.insertLast(4);
list.printList();        // Output: 1 --> 2 --> 3 --> 4 --> NULL
```

## Complete Code Implementation

```cpp
/*
============================================================
* Project: [Single Linked List Implementation]
* File:    [SLinkedList.cpp]
* Author:  [Ali El-bana]
* Date:    [2025-08-11]
* Version: [v1.0]
------------------------------------------------------------
* Description:
* [Self implementation of a single linked list]
------------------------------------------------------------
* Notes:
* [This is for an educational purpose]
============================================================
*/

#include <iostream>
#include <string>

using std::cout;
using std::cin;
using std::endl;

class Node {
public:
    int data;
    Node * next;
    
    Node(int val) : data(val), next(nullptr){}
};

class LinkedList {
private:
    Node * head;
    Node * tail;
    size_t length;
    
public:
    LinkedList(): head(nullptr), tail(nullptr), length(0){}
    
    ~LinkedList() {
        while(head != nullptr) {
            Node * tmp = head;
            head = tmp->next;
            delete tmp;
        }
    }
    
    int getAt(size_t idx) {
        Node * currNode = head;
        
        if(idx >= length) {
            cout << "\nIndex out of range.";
        }
        else {
            size_t i{0};
            while(i != idx) {
                currNode = currNode->next;
                i++;
            }
        }
        return currNode->data;
    }
    
    void insertLast(int val) {
        Node * newNode = new Node(val);
        
        if(head == nullptr) {
            head = newNode;
            tail = newNode;
        }
        else {
            tail->next = newNode;
            newNode->next = nullptr;
            tail = newNode;
        }
        length++; 
    }
    
    void printList() {
        Node * currNode = head;
        
        cout << '\n';
        while(currNode != nullptr) {
            cout << currNode->data << " --> ";
            currNode = currNode->next;
        }
        cout << "NULL\n";
    }
    
    size_t getLength(void) {
        return length;
    }
};

int main(void) {
    system("cls");
    cout << "Program started...\n";
    LinkedList list;
    
    list.insertLast(1);
    list.insertLast(2);
    list.insertLast(3);
    list.insertLast(4);
    list.printList();
    
    size_t length = list.getLength();
    cout << "\nThe linked list length = " << length << '\n';
    
    return 0;
}
```

## Potential Improvements

- [ ] Add `insertFirst()` method
- [ ] Implement `deleteAt(idx)` functionality
- [ ] Add `search(value)` method
- [ ] Template support for generic data types
- [ ] Iterator implementation for range-based loops
- [ ] Copy constructor and assignment operator (Rule of Three)

## Related Concepts

- [[Dynamic Memory Allocation]]
- [[Pointer Manipulation]]
- [[Object-Oriented Programming]]
- [[Data Structures]]
- [[Memory Management]]

---

**Tags**: #cpp #datastructures #linkedlist #pointers #oop #memory-management
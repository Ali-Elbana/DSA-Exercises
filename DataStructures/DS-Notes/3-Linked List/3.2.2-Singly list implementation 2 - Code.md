# Enhanced Single Linked List Implementation v2

## Overview

An advanced C++ implementation of a singly linked list with comprehensive manipulation methods including positional insertion, deletion, and enhanced node access functionality. This version extends the basic linked list with sophisticated operations for complete list control.

**Author**: Ali El-bana  
**Date**: 2025-08-12  
**Version**: v2.0  
**Enhancement Focus**: Adding `getNodeAt()`, `insertAfter()`, `insertBefore()`, `deleteNode()`

## Version 2 Enhancements

- ✅ **Node-level Access**: Direct pointer retrieval with `getNodeAt()`
- ✅ **Positional Insertion**: Insert before/after any index
- ✅ **Comprehensive Deletion**: Delete nodes at any position with full edge case handling
- ✅ **Enhanced Error Handling**: Using `std::cerr` for error output
- ✅ **Advanced Operations**: Complete CRUD operations on linked list

## Class Architecture

### Node Class

```cpp
class Node {
public:
    int data;      // Integer value stored
    Node * next;   // Pointer to next node
    
    Node(int val) : data(val), next(nullptr) {}
};
```

**Purpose**: Represents individual list elements with clean initialization

### LinkedList Class Structure

```cpp
class LinkedList {
private:
    Node * head;    // First node pointer
    Node * tail;    // Last node pointer (optimization)
    size_t length;  // Current list size
    
public:
    // Constructor, destructor, and 8 core methods
};
```

## Enhanced Method Analysis

### Access Methods Comparison

|Method|Return Type|Purpose|Time Complexity|
|---|---|---|---|
|`getDataAt(idx)`|`int`|Returns data value|O(n)|
|`getNodeAt(idx)`|`Node*`|Returns node pointer|O(n)|

#### `getNodeAt(size_t idx)` - NEW METHOD

```cpp
Node * getNodeAt(size_t idx) {
    Node * currNode = head;
    
    if(idx >= length) {
        cerr << "\nIndex out of range.";
    }
    else {
        size_t i{0};
        while(i < idx) {
            currNode = currNode->next;
            i++;
        }
    }
    return currNode;
}
```

**Key Features**:

- **Direct Node Access**: Returns pointer for advanced operations
- **Foundation Method**: Used by other advanced operations
- **Error Handling**: Uses `cerr` for error output

### Advanced Insertion Operations

#### `insertAfter(size_t idx, int newData)`

**Strategy**: Insert new node immediately after specified position

```cpp
void inserAfter(size_t idx, int newData) {
    Node * currNode = getNodeAt(idx);
    Node * newNode = new Node(newData);
    
    newNode->next = currNode->next;  // Link to next
    currNode->next = newNode;        // Link from current
    
    if(currNode == tail) {           // Tail update check
        tail = newNode;
    }
    length++;
}
```

**Edge Cases**:

- **After Tail**: Automatically updates tail pointer
- **Middle Insertion**: Standard link manipulation
- **Validation**: Index bounds checking

#### `insertBefore(size_t idx, int newData)`

**Strategy**: Two-case approach for optimal efficiency

```cpp
void insertBefore(size_t idx, int newData) {
    if(idx == 0) {
        // Head insertion - direct approach
        Node * newNode = new Node(newData);
        newNode->next = head;
        head = newNode;
    }
    else {
        // General case - insert after previous node
        Node * prevNode = getNodeAt(idx - 1);
        Node * newNode = new Node(newData);
        
        newNode->next = prevNode->next;
        prevNode->next = newNode;
    }
    length++;
}
```

**Optimization**:

- **Head Case**: O(1) operation without traversal
- **General Case**: Clever reuse of `insertAfter` logic on previous node

### Comprehensive Deletion Method

#### `deleteNode(size_t idx)` - ADVANCED DELETION

**Strategy**: Four-case approach handling all scenarios

```cpp
void deleteNode(size_t idx) {
    if(idx >= length) {
        cerr << "\nIndex out of range.";
    }
    else if(idx == 0 && length == 1) {
        // Single node case
        Node * currNode = getNodeAt(idx);
        head = nullptr;
        tail = nullptr;
        delete currNode;
        length--;
    }
    else if(idx == 0) {
        // Delete head (multiple nodes)
        Node * currNode = head;
        head = currNode->next;
        delete currNode;
        length--;
    }
    else if(idx == (length - 1)) {
        // Delete tail
        Node * currNode = tail;
        Node * prevNode = getNodeAt(length - 2);
        prevNode->next = currNode->next;  // Should be nullptr
        tail = prevNode;
        delete currNode;
        length--;
    }
    else {
        // Delete middle node
        Node * currNode = getNodeAt(idx);
        Node * prevNode = getNodeAt(idx - 1);
        prevNode->next = currNode->next;
        delete currNode;
        length--;
    }
}
```

**Deletion Scenarios**:

1. **Single Node**: Reset both head and tail to nullptr
2. **Head Deletion**: Update head to next node
3. **Tail Deletion**: Find previous node and update tail
4. **Middle Deletion**: Standard link bypass operation

## Memory Management Strategy

### Dynamic Allocation

- **Node Creation**: Each operation allocates using `new`
- **Node Deletion**: Proper cleanup with `delete`
- **List Destruction**: Comprehensive cleanup in destructor

### Pointer Safety

- **Null Validation**: Bounds checking before operations
- **Link Integrity**: Careful pointer updates to maintain structure
- **Memory Leak Prevention**: Systematic deallocation

## Performance Characteristics

### Time Complexity Analysis

|Operation|Best Case|Average Case|Worst Case|Notes|
|---|---|---|---|---|
|`getNodeAt()`|O(1)|O(n/2)|O(n)|Index 0 vs last|
|`insertAfter()`|O(1)|O(n/2)|O(n)|Depends on position|
|`insertBefore()`|O(1)|O(n/2)|O(n)|Head = O(1)|
|`deleteNode()`|O(1)|O(n/2)|O(n)|Head/tail optimized|

### Space Complexity

- **List Storage**: O(n) where n = number of nodes
- **Operation Overhead**: O(1) per method call

## Sample Execution Trace

### Initial Setup

```cpp
list.insertLast(10);     // [10]
list.insertLast(20);     // [10, 20]
list.insertLast(30);     // [10, 20, 30]
list.insertLast(40);     // [10, 20, 30, 40]
```

### Advanced Operations

```cpp
list.inserAfter(1, 25);   // [10, 20, 25, 30, 40]
list.insertBefore(4, 35); // [10, 20, 25, 30, 35, 40]
```

### Deletion Sequence

```cpp
list.deleteNode(0);       // Delete head: [20, 25, 30, 35, 40]
list.deleteNode(length-1); // Delete tail: [20, 25, 30, 35]
list.deleteNode(1);       // Delete middle: [20, 30, 35]
```

## Error Handling & Validation

### Input Validation Strategy

- **Range Checking**: All methods validate index bounds
- **Error Output**: Uses `std::cerr` for error messages
- **Graceful Continuation**: Methods continue after error reporting

### Edge Case Coverage

- **Empty List**: Proper initialization handling
- **Single Node**: Special case logic for head == tail
- **Boundary Operations**: Head and tail manipulation safety

## Complete Code Implementation

```cpp
/*
============================================================
* Project: [Single Linked List Implementation 2]
* File:    [SLinkedList2.cpp]
* Author:  [Ali El-bana]
* Date:    [2025-08-12]
* Version: [v2.0]
------------------------------------------------------------
* Description:
* [Adding methods like: getNodeAt(), insertAfter(), 
*  insertBefore(), deleteNode()]
------------------------------------------------------------
* Notes:
* [This is for an educational purpose]
============================================================
*/

#include <iostream>
#include <string>

using std::cout;
using std::cin;
using std::cerr;
using std::endl;

class Node {
public:
    int data;
    Node * next;
    
    Node(int val) : data(val), next(nullptr){}
};

class LinkedList {
private:
    Node * head;
    Node * tail;
    size_t length;
    
public:
    LinkedList(): head(nullptr), tail(nullptr), length(0){}
    
    ~LinkedList() {
        while(head != nullptr) {
            Node * tmp = head;
            head = tmp->next;
            delete tmp;
        }
    }
    
    int getDataAt(size_t idx) {
        Node * currNode = head;
        
        if(idx >= length) {
            cout << "\nIndex out of range.";
        }
        else {
            size_t i{0};
            while(i != idx) {
                currNode = currNode->next;
                i++;
            }
        }
        return currNode->data;
    }
    
    Node * getNodeAt(size_t idx) {
        Node * currNode = head;
        
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else {
            size_t i{0};
            while(i < idx) {
                currNode = currNode->next;
                i++;
            }
        }
        return currNode;
    }
    
    void insertLast(int val) {
        Node * newNode = new Node(val);
        
        if(head == nullptr) {
            head = newNode;
            tail = newNode;
        }
        else {
            tail->next = newNode;
            newNode->next = nullptr;
            tail = newNode;
        }
        length++; 
    }
    
    void inserAfter(size_t idx, int newData) {
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else {
            Node * currNode = getNodeAt(idx);
            Node * newNode = new Node(newData);
            
            newNode->next = currNode->next;
            currNode->next = newNode;
            
            if(currNode == tail) {
                tail = newNode;
            }
            length++; 
        }
    }
    
    void insertBefore(size_t idx, int newData) {
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else if(idx == 0) {
            Node * currNode = head;
            Node * newNode = new Node(newData);
            
            newNode->next = currNode;
            head = newNode;
            length++; 
        }
        else {
            Node * currNode = getNodeAt(idx - 1);
            Node * newNode = new Node(newData);
            
            newNode->next = currNode->next;
            currNode->next = newNode;
            length++; 
        }
    }
    
    void deleteNode(size_t idx) {
        if(idx >= length) {
            cerr << "\nIndex out of range.";
        }
        else if(idx == 0 && length == 1) {
            Node * currNode = getNodeAt(idx);
            head = nullptr;
            tail = nullptr;
            delete currNode;
            length--;
        }
        else if(idx == 0) {
            Node * currNode = head;
            head = currNode->next;
            delete currNode; 
            length--; 
        }
        else if(idx == (length - 1)) {
            Node * currNode = tail;
            Node * prevNode = getNodeAt(length - 2);
            prevNode->next = currNode->next;
            tail = prevNode;
            delete currNode;
            length--; 
        }
        else {
            Node * currNode = getNodeAt(idx);
            Node * prevNode = getNodeAt(idx - 1);
            prevNode->next = currNode->next;
            delete currNode;
            length--; 
        }
    }
    
    void printList() {
        Node * currNode = head;
        
        cout << '\n';
        while(currNode != nullptr) {
            cout << currNode->data << " --> ";
            currNode = currNode->next;
        }
        cout << "NULL\n";
    }
    
    size_t getLength(void) {
        return length;
    }
};

int main(void) {
    system("cls");
    cout << "\nProgram started...\n";
    LinkedList list;
    
    list.insertLast(10);
    list.insertLast(20);
    list.insertLast(30);
    list.insertLast(40);
    list.inserAfter(1, 25);
    list.insertBefore(4, 35);
    list.printList();
    
    cout << "\nDelete the head of the list:";
    list.deleteNode(0);
    list.printList();
    
    size_t length = list.getLength();
    
    cout << "\nDelete the tail of the list:";
    list.deleteNode(length - 1);
    list.printList();
    
    cout << "\nDelete a node from the list:";
    list.deleteNode(1);
    list.printList();
    
    int data = list.getDataAt(1);
    cout << "\nThe Node at index " << 1 << " its data = " << data;
    cout << "\nThe linked list length = " << list.getLength() << '\n';
    
    return 0;
}
```

## Method Implementation Details

### Core Access Methods

#### `getDataAt(size_t idx)` - Data Retrieval

```cpp
int getDataAt(size_t idx)
```

- **Purpose**: Retrieve integer value at specified index
- **Validation**: Index bounds checking with error message
- **Traversal**: Sequential from head to target position

#### `getNodeAt(size_t idx)` - Node Pointer Retrieval

```cpp
Node * getNodeAt(size_t idx)
```

- **Purpose**: Return direct pointer to node for advanced operations
- **Foundation**: Enables all other positional operations
- **Usage**: Internal helper for insertion/deletion methods

### Positional Insertion Methods

#### `insertAfter(size_t idx, int newData)`

**Algorithm Steps**:

1. Validate index bounds
2. Get pointer to current node at index
3. Create new node with data
4. Link new node to current's next
5. Link current node to new node
6. Update tail pointer if inserting after tail
7. Increment length

**Visual Representation**:

```
Before: [A] -> [B] -> [C]
insertAfter(1, X):
After:  [A] -> [B] -> [X] -> [C]
```

#### `insertBefore(size_t idx, int newData)`

**Two-Strategy Approach**:

**Case 1: Insert at Head (idx == 0)**

```cpp
Node * newNode = new Node(newData);
newNode->next = head;
head = newNode;
```

**Case 2: General Case**

```cpp
Node * prevNode = getNodeAt(idx - 1);  // Get previous node
newNode->next = prevNode->next;        // Insert after previous
prevNode->next = newNode;
```

**Visual Representation**:

```
Before: [A] -> [B] -> [C]
insertBefore(2, X):
After:  [A] -> [B] -> [X] -> [C]
```

### Comprehensive Deletion Method

#### `deleteNode(size_t idx)` - Four-Case Deletion

**Complete Edge Case Handling**:

1. **Single Node Deletion** (`idx == 0 && length == 1`)
    
    - Reset both head and tail to nullptr
    - Delete the only existing node
2. **Head Deletion** (`idx == 0`)
    
    - Update head to point to second node
    - Delete original head
3. **Tail Deletion** (`idx == length - 1`)
    
    - Find second-to-last node
    - Update its next to nullptr
    - Update tail pointer
    - Delete original tail
4. **Middle Deletion** (general case)
    
    - Get current and previous nodes
    - Bypass current node in links
    - Delete current node

## Execution Flow Analysis

### Sample Program Execution

```cpp
// Initial list building
insertLast(10);          // [10]
insertLast(20);          // [10, 20]
insertLast(30);          // [10, 20, 30]
insertLast(40);          // [10, 20, 30, 40]

// Advanced insertions
inserAfter(1, 25);       // [10, 20, 25, 30, 40]
insertBefore(4, 35);     // [10, 20, 25, 30, 35, 40]

// Deletion sequence
deleteNode(0);           // [20, 25, 30, 35, 40]  (head)
deleteNode(length-1);    // [20, 25, 30, 35]      (tail)
deleteNode(1);           // [20, 30, 35]          (middle)
```

### Expected Output

```
10 --> 20 --> 25 --> 30 --> 35 --> 40 --> NULL

Delete the head of the list:
20 --> 25 --> 30 --> 35 --> 40 --> NULL

Delete the tail of the list:
20 --> 25 --> 30 --> 35 --> NULL

Delete a node from the list:
20 --> 30 --> 35 --> NULL

The Node at index 1 its data = 30
The linked list length = 3
```

## Code Quality Analysis

### Strengths

- ✅ **Comprehensive Operations**: Full CRUD functionality
- ✅ **Edge Case Handling**: Thorough consideration of special cases
- ✅ **Memory Management**: Proper allocation and deallocation
- ✅ **Code Organization**: Clear sectioning and commenting
- ✅ **Error Handling**: Bounds checking and error reporting

### Areas for Improvement

- [ ] **Exception Handling**: Consider throwing exceptions instead of error messages
- [ ] **Return Value Validation**: Handle failed operations more gracefully
- [ ] **Const Correctness**: Add const methods where appropriate
- [ ] **Template Support**: Generic data type implementation
- [ ] **Iterator Pattern**: Add iterator for range-based loops

## Future Enhancements

- [ ] `insertFirst()` method for head insertion
- [ ] `search(value)` functionality
- [ ] `reverse()` method implementation
- [ ] `merge()` for combining lists
- [ ] `sort()` functionality
- [ ] Copy constructor and assignment operator
- [ ] Move semantics support

## Related Concepts

- [[Advanced Pointer Manipulation]]
- [[Dynamic Memory Management]]
- [[Algorithm Edge Cases]]
- [[Data Structure Design Patterns]]
- [[C++ RAII Principles]]
- [[Time Complexity Analysis]]

---

**Tags**: #cpp #datastructures #linkedlist #advanced-operations #pointers #memory-management #algorithms #educational

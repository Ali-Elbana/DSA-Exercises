
**Video explanation by AI:** [Watch the video here](https://notebooklm.google.com/notebook/68a51878-3ce2-4a6e-ba12-62bb4ec9e31e?artifactId=dd1a66be-4611-4769-b5b1-f2ee12ebcc70)

---
## Doubly Linked List Implementation Notes

This document describes a self-implementation of a doubly linked list in C++, intended for educational purposes. It includes class definitions for `Node` and `LinkedList`, along with various methods for common linked list operations.

**The code reference:** [[3.3.2-Doubly list implementation - Code#Complete Code Implementation]]

---
### 1. Core Concepts and Structure

- **Doubly Linked List:** A data structure where each element (node) contains references (or pointers) to both the next and the previous nodes in the sequence. This allows for traversal in both forward and backward directions.
- **Node Class:**
    - Each `Node` object stores an `int` type `data` value.
    - It has two pointers: `next` (to the succeeding node) and `prev` (to the preceding node).
    - The `Node` constructor initializes `data` with a given value and sets both `next` and `prev` pointers to `nullptr`.
- **LinkedList Class:**
    - Manages the collection of `Node` objects.
    - Contains three private members:
        - `head`: A pointer to the first node in the list.
        - `tail`: A pointer to the last node in the list.
        - `length`: A `size_t` variable to keep track of the number of nodes in the list.
    - The `LinkedList` constructor initializes `head` and `tail` to `nullptr` and `length` to 0.
    - The **destructor (`~LinkedList`)** deallocates all nodes in the list by iterating from the `head` and deleting each node until the list is empty.

[![DLinkedList](G:\DSA\Slides\DLList\s1.png)

---
### 2. Key Operations (Methods)

The `LinkedList` class provides several public methods to manipulate the list:

- **`insertLast(int val)`**:
    - **Purpose:** Adds a new node with the specified `val` at the end of the list.
    - **Process:**
        - A new `Node` is created with the given `val`.
        - **If the list is empty** (`head` is `nullptr`), the new node becomes both the `head` and `tail`.
        - **Otherwise**, the `next` pointer of the current `tail` is set to point to the `newNode`, the `prev` pointer of the `newNode` is set to the current `tail`, and `newNode->next` is set to `nullptr`. The `tail` pointer is then updated to point to the `newNode`.
        - The `length` of the list is incremented.

[![DLinkedList](G:\DSA\Slides\DLList\s5.png)

[![DLinkedList](G:\DSA\Slides\DLList\s6.png)

[![DLinkedList](G:\DSA\Slides\DLList\s7.png)

[![DLinkedList](G:\DSA\Slides\DLList\s8.png)

[![DLinkedList](G:\DSA\Slides\DLList\s9.png)

[![DLinkedList](G:\DSA\Slides\DLList\s10.png)

[![DLinkedList](G:\DSA\Slides\DLList\s11.png)

- **`inserAfter(size_t idx, int newData)`**:
    - **Purpose:** Inserts a new node with `newData` after the node at the specified `idx`.
    - **Process:**
        - **Validation:** Checks if `idx` is within the valid range (`idx >= length`). If out of range, an error message is displayed.
        - If valid, it retrieves the node at `idx` using `getNodeAt(idx)`.
        - A `newNode` is created.
        - `newNode->prev` is set to the current node (`currNode`).
        - `newNode->next` is set to `currNode->next`.
        - `currNode->next` is set to `newNode`.
        - **Special Case (Adding after tail):** If `currNode` was the `tail`, the `tail` pointer is updated to `newNode`.
        - **General Case (Adding in between):** If not adding after the tail, the `prev` pointer of the node that was originally `currNode->next` (now `newNode->next`) is set to `newNode`.
        - The `length` is incremented.

[![DLinkedList](G:\DSA\Slides\DLList\s3.png)

[![DLinkedList](G:\DSA\Slides\DLList\s4.png)

- **`insertBefore(size_t idx, int newData)`**:
    - **Purpose:** Inserts a new node with `newData` before the node at the specified `idx`.
    - **Process:**
        - **Validation:** Checks if `idx` is within the valid range. If out of range, an error message is displayed.
        - **Special Case (Insert before head, `idx == 0`):**
            - A `newNode` is created.
            - `newNode->prev` is set to `nullptr`.
            - `newNode->next` is set to the current `head` (`currNode`).
            - `currNode->prev` is set to `newNode`.
            - The `head` pointer is updated to `newNode`.
        - **General Case (Insert in between):**
            - Retrieves the node at `idx` (`currNode`).
            - A `newNode` is created.
            - `newNode->next` is set to `currNode`.
            - `newNode->prev` is set to `currNode->prev`.
            - `currNode->prev` is set to `newNode`.
            - The `next` pointer of the node _before_ `currNode` (i.e., `newNode->prev->next`) is set to `newNode`.
        - The `length` is incremented.


- **`deleteNode(size_t idx)`**:
    - **Purpose:** Deletes the node at the specified `idx`.
    - **Process:**
        - **Validation:** Checks if `idx` is within the valid range (`idx >= length`). If out of range, an error message is displayed.
        - **Special Case (Only one node, `idx == 0 && length == 1`):** Both `head` and `tail` are set to `nullptr`, and the node is deleted.
        - **Special Case (Delete head, `idx == 0`):**
            - The `prev` pointer of the next node (`currNode->next`) is set to `nullptr`.
            - The `head` pointer is updated to `currNode->next`.
            - The `currNode` (old head) is deleted.
        - **Special Case (Delete tail, `idx == (length - 1)`):**
            - The `next` pointer of the previous node (`currNode->prev`) is set to `nullptr`.
            - The `tail` pointer is updated to `currNode->prev`.
            - The `currNode` (old tail) is deleted.
        - **General Case (Delete in between):**
            - Retrieves the node at `idx` (`currNode`).
            - The `next` pointer of the node _before_ `currNode` (`currNode->prev->next`) is set to `currNode->next`.
            - The `prev` pointer of the node _after_ `currNode` (`currNode->next->prev`) is set to `currNode->prev`.
            - The `currNode` is deleted.
        - In all successful deletion cases, the `length` of the list is decremented.

[![DLinkedList](G:\DSA\Slides\DLList\s12.png)

[![DLinkedList](G:\DSA\Slides\DLList\s13.png)

[![DLinkedList](G:\DSA\Slides\DLList\s14.png)

---
### 3. Example Usage (Main Application)

The `main` function demonstrates the usage of these methods.

- It initializes a `LinkedList` object.
- **Inserts nodes:** `insertLast` (10, 20, 30, 40), `inserAfter` (1, 25), `inserAfter` (after tail, 45), `insertBefore` (4, 35).
- Prints the list.
- **Deletes nodes:** Demonstrates deleting the head, the tail, and an in-between node.
- Prints the list after each deletion.
- Retrieves and prints data at a specific index (`getDataAt`) and the final length of the list (`getLength`).

---
